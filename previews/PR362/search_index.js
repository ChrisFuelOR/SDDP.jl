var documenterSearchIndex = {"docs":
[{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"EditURL = \"https://github.com/odow/SDDP.jl/blob/master/docs/src/tutorial/01_first_steps.jl\"","category":"page"},{"location":"tutorial/01_first_steps/#Basic-I:-first-steps","page":"Basic I: first steps","title":"Basic I: first steps","text":"","category":"section"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"SDDP.jl is a solver for multistage stochastic optimization problems. By multistage, we mean problems in which the agent makes a sequence of decisions over time. By stochastic, we mean that our agent is making decisions in the presence of uncertainty that is gradually revealed over the multiple stages.","category":"page"},{"location":"tutorial/01_first_steps/#Background-theory","page":"Basic I: first steps","title":"Background theory","text":"","category":"section"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"Multistage stochastic programming is complicated, and the literature has not settled upon standard naming conventions, so we must begin with some unavoidable theory and notation.","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"A multistage stochastic program can be modeled by a policy graph. A policy graph is a graph with nodes and arcs. The simplest type of policy graph is a linear graph. Here's a linear graph with three nodes:","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"(Image: Linear policy graph)","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"In addition to nodes 1, 2, and 3, there is also a root node (0), and three arcs. Each arc has an origin node and a destination node, like 0 => 1, and a corresponding probability of transitioning from the origin to the destination. For now, we can forget about the arc probabilities, because they are all 1.0.","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"We denote the set of nodes by mathcalN, the root node by R, and the probability of transitioning from node i to node j by p_ij. (If no arc exists, then p_ij = 0). We define the set of successors of node i as i^+ = j in N  P(i = j)  0.","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"Each square node in the graph corresponds to a place at which the agent makes a decision, and we call moments in time at which the agent makes a decision stages. By convention, we try to draw policy graphs from left-to-right, with the stages as columns. (There can be more than one node in a stage! We will see such examples in future tutorials when our graph has rows as well as columns.)","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"A common feature of multistage stochastic optimization problems is that they model an agent controlling a system over time. This system can be described by three types of variables.","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"State variables track a property of the system over time.\nEach node has an associated incoming state variable (the value of the state at the start of the node), and an outgoing state variable (the value of the state at the end of the node).\nExamples of state variables include the volume of water in a reservoir, the number of units of inventory in a warehouse, or the spatial position of a moving vehicle.\nBecause state variables track the system over time, each node must have the same set of state variables.\nWe denote state variables by the letter x for the incoming state variable and x^prime for the outgoing state variable.\nControl variables are actions taken (implicitly or explicitly) by the agent within a node which modify the state variables.\nExamples of control variables include releases of water from the reservoir, sales or purchasing decisions, and acceleration or braking of the vehicle.\nControl variables are local to a node i, and they can differ between nodes. For example, some control variables may be available within certain nodes.\nWe denote control variables by the letter u.\nRandom variables are finite, discrete, exogenous random variables that the agent observes at the start of a node, before the control variables are decided.\nExamples of random variables include rainfall inflow into a reservoir, probalistic perishing of inventory, and steering errors in a vehicle.\nRandom variables are local to a node i, and they can differ between nodes. For example, some nodes may have random variables, and some nodes may not.\nWe denote random variables by the Greek letter omega and the sample space from which they are drawn by Omega_i. The probability of sampling omega is denoted p_omega for simplicity.","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"In a node i, the three variables are related by a transition function, which maps the incoming state, the controls, and the random variables to the outgoing state as follows: x^prime = T_i(x u omega).","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"As a result of entering a node i with the incoming state x, observing random variable omega, and choosing control u, the agent incurs a cost C_i(x u omega). (If the agent is a maximizer, this can be a profit, or a negative cost.) We call C_i the stage objective.","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"To choose their control variables in node i, the agent uses a decision rule u = pi_i(x omega), which is a function that maps the incoming state variable and observation of the random variable to a control u. This control must satisfy some feasibilty requirements u in U_i(x omega).","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"The set of decision rules, with one element for each node in the policy graph, is called a policy.","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"The goal of the agent is to find a policy that minimizes the expected cost of starting at the root node with some initial condition x_R, and proceeding from node to node along the probabilistic arcs until they reach a node with no outgoing arcs.","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"min_pi mathbbE_i in R^+ omega in Omega_iV_i^pi(x_R omega)","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"where","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"V_i^pi(x omega) = C_i(x u omega) + mathbbE_j in i^+ varphi in Omega_jV_j(x^prime varphi)","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"where u = pi_i(x omega) in U_i(x omega), and x^prime = T_i(x u omega).","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"The expectations are a bit complicated, but they are equivalent to:","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"mathbbE_j in i^+ varphi in Omega_jV_j(x^prime varphi) = sumlimits_j in i^+ p_ij leftsumlimits_varphi in Omega_j p_varphileftV_j(x^prime varphi)rightright","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"An optimal policy is the set of decision rules that the agent can use to make these decisions and achieve the smallest expected cost.","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"Often, computing the cost of a policy is intractable due to the large number of nodes or possible realizations of the random variables. Instead, we can evaluate the policy using a Monte Carlo simulation. Each replicate of the simulation starts at the root node and probabilistically walks along the arcs of the policy graph until it reaches a node with not outgoing arcs. The cost of a replicate is the sum of the costs incurred at each node that was visited.","category":"page"},{"location":"tutorial/01_first_steps/#Dynamic-programming-and-subproblems","page":"Basic I: first steps","title":"Dynamic programming and subproblems","text":"","category":"section"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"Now that we have formulated our problem, we need some ways of computing optimal decision rules. One way is to just use a heuristic like \"choose a control randomally from the set of feasible controls.\" However, such a policy is unlikely to be optimal.","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"One way of obtaining an optimal policy is to use Bellman's principle of optimality, a.k.a Dynamic Programming, and define a recursive subproblem as follows:","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"beginaligned\nV_i(x omega) = minlimits_barx x^prime u   C_i(barx u omega) + mathbbE_j in i^+ varphi in Omega_jV_j(x^prime varphi)\n x^prime = T_i(barx u omega) \n u in U_i(barx omega) \n barx = x\nendaligned","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"Our decision rule, pi_i(x omega), solves this optimization problem and returns a u^* corresponding to an optimal solution.","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"note: Note\nWe add barx as a decision variable, along with the fishing constraint barx = x for two reasons: it makes it obvious that formulating a problem with x times u results in a bilinear program instead of a linear program, and it simplifies that internal algorithm that SDDP.jl uses to find an optimal policy.","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"These subproblems are very difficult to solve exactly, because they involve recursive optimization problems with lots of nested expectations.","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"Therefore, instead of solving them exactly, SDDP.jl works by iteratively approximating the expectation term of each subproblem, which is also called the cost-to-go term. For now, you don't need to understand the details, other than that there is a nasty cost-to-go term that we deal with behind-the-scenes.","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"The subproblem view of a multistage stochastic program is also important, because it provides a convienient way of communicating the different parts of the broader problem, and it is how we will communicate the problem to SDDP.jl. All we need to do is drop the cost-to-go term and fishing constraint, and define a new subproblem SP as:","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"beginaligned\ntextttSP_i(x omega)  minlimits_barx x^prime u   C_i(barx u omega) \n x^prime = T_i(barx u omega) \n u in U_i(barx omega) \nendaligned","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"note: Note\nWhen we talk about formulating a subproblem with SDDP.jl, this is the formulation we mean.","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"We've retained the transition function and uncertainty set because they help to motivate the different components of the subproblem. However, in general, the subproblem can be more general. A better (less restrictive) representation might be:","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"beginaligned\ntextttSP_i(x omega)  minlimits_barx x^prime u   C_i(barx x^prime u omega) \n (barx x^prime u) in mathcalX_i(omega)\nendaligned","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"Note that the outgoing state variable can appear in the objective, and we can add constraints involving the incoming and outgoing state variables. It should be obvious how to map between the two representations.","category":"page"},{"location":"tutorial/01_first_steps/#Example:-hydro-thermal-scheduling","page":"Basic I: first steps","title":"Example: hydro-thermal scheduling","text":"","category":"section"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"Hydrothermal scheduling is the most common application of stochastic dual dynamic programming. To illustrate some of the basic functionality of SDDP.jl, we implement a very simple model of the hydrothermal scheduling problem. To make things even simpler to start with, we're not going to include any uncertainty; that will come in the next tutorial.","category":"page"},{"location":"tutorial/01_first_steps/#Problem-statement","page":"Basic I: first steps","title":"Problem statement","text":"","category":"section"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"We consider the problem of scheduling electrical generation over three weeks in order to meet a known demand of 150 MWh in each week.","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"There are two generators: a thermal generator, and a hydro generator. In each week, the agent needs to decide how much energy to generate from thermal, and how much energy to generate from hydro.","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"The thermal generator has a short-run marginal cost of \\$50/MWh in the first stage, \\$100/MWh in the second stage, and \\$150/MWh in the third stage.","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"The hydro generator has a short-run marginal cost of \\$0/MWh.","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"The hydro generator draws water from a reservoir which has a maximum capacity of 200 MWh. (Although water is usually measured in m³, we measure it in the energy-equivalent MWh to simplify things. In practice, there is a conversion function between m³ flowing throw the turbine and MWh.) At the start of the first time period, the reservoir is full.","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"In addition to the ability to generate electricity by passing water through the hydroelectric turbine, the hydro generator can also spill water down a spillway (bypassing the turbine) in order to prevent the water from over-topping the dam. We assume that there is no cost of spillage.","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"The goal of the agent is to minimize the expected cost of generation over the three weeks.","category":"page"},{"location":"tutorial/01_first_steps/#Formulating-the-problem","page":"Basic I: first steps","title":"Formulating the problem","text":"","category":"section"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"Before going further, we need to load SDDP.jl:","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"using SDDP","category":"page"},{"location":"tutorial/01_first_steps/#Graph-structure","page":"Basic I: first steps","title":"Graph structure","text":"","category":"section"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"First, we need to identify the structre of the policy graph. From the problem statement, we want to model the problem over three weeks in weekly stages. Therefore, the policy graph is a linear graph with three stages:","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"graph = SDDP.LinearGraph(3)","category":"page"},{"location":"tutorial/01_first_steps/#Building-the-subproblem","page":"Basic I: first steps","title":"Building the subproblem","text":"","category":"section"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"Next, we need to construct the associated subproblem for each node in graph. To do so, we need to provide SDDP.jl a function which takes two arguments. The first is subproblem::Model, which is an empty JuMP model. The second is node, which is the name of each node in the policy graph. If the graph is linear, SDDP defaults to naming the nodes using the integers in 1:T. Here's an example that we are going to flesh out over the next few paragraphs:","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"function subproblem_builder(subproblem::Model, node::Int)\n    # ... stuff to go here ...\n    return subproblem\nend","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"note: Note\nWe don't need to add the fishing constraint barx = x; SDDP.jl does this automatically.","category":"page"},{"location":"tutorial/01_first_steps/#State-variables","page":"Basic I: first steps","title":"State variables","text":"","category":"section"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"The first part of the subproblem we need to identify are the state variables. Since we only have one reservoir, there is only one state variable, volume, the volume of water in the reservoir [MWh].","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"The volume had bounds of [0, 200], and the reservoir was full at the start of time, so x_R = 200.","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"We add state variables to our subproblem using JuMP's @variable macro. However, in addition to the usual syntax, we also pass SDDP.State, and we need to provide the initial value (x_R) using the initial_value keyword.","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"function subproblem_builder(subproblem::Model, node::Int)\n    # State variables\n    @variable(subproblem, 0 <= volume <= 200, SDDP.State, initial_value = 200)\n    return subproblem\nend","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"The syntax for adding a state variable is a little obtuse, because volume is not single JuMP variable. Instead, volume is a struct with two fields, .in and .out, corresponding to the incoming and outgoing state variables respectively.","category":"page"},{"location":"tutorial/01_first_steps/#Control-variables","page":"Basic I: first steps","title":"Control variables","text":"","category":"section"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"The next part of the subproblem we need to identiy are the control variables. The control variables for our problem are:","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"thermal_generation: the quantity of energy generated from thermal [MWh/week]\nhydro_generation: the quantity of energy generated from hydro [MWh/week]\nhydro_spill: the volume of water spilled from the reservoir in each week [MWh/week]","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"Each of these variables is non-negative.","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"We add control variables to our subproblem as normal JuMP variables, using @variable or @variables:","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"function subproblem_builder(subproblem::Model, node::Int)\n    # State variables\n    @variable(subproblem, 0 <= volume <= 200, SDDP.State, initial_value = 200)\n    # Control variables\n    @variables(subproblem, begin\n        thermal_generation >= 0\n        hydro_generation   >= 0\n        hydro_spill        >= 0\n    end)\n    return subproblem\nend","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"tip: Tip\nModeling is an art, and a tricky part of that art is figuring out which variables are state variables, and which are control variables. A good rule is: if you need a value of a control variable in some future node to make a decision, it is a state variable instead.","category":"page"},{"location":"tutorial/01_first_steps/#Random-variables","page":"Basic I: first steps","title":"Random variables","text":"","category":"section"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"The next step is to identify any random variables. In this simple example, there are none, so we can skip it.","category":"page"},{"location":"tutorial/01_first_steps/#Transition-function-and-contraints","page":"Basic I: first steps","title":"Transition function and contraints","text":"","category":"section"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"Now that we've identified our variables, we can define the transition function and the constraints.","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"For our problem, the state variable is the volume of water in the reservoir. The volume of water decreases in response to water being used for hydro generation and spillage. So the transition function is: volume.out = volume.in - hydro_generation - hydro_spill. (Note how we use volume.in and volume.out to refer to the incoming and outgoing state variables.)","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"There is also a constraint that the total generation must sum to 150 MWh.","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"Both the transition function and any additional constraint are added using JuMP's @constraint and @constraints macro.","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"function subproblem_builder(subproblem::Model, node::Int)\n    # State variables\n    @variable(subproblem, 0 <= volume <= 200, SDDP.State, initial_value = 200)\n    # Control variables\n    @variables(subproblem, begin\n        thermal_generation >= 0\n        hydro_generation   >= 0\n        hydro_spill        >= 0\n    end)\n    # Transition function and constraints\n    @constraints(subproblem, begin\n        volume.out == volume.in - hydro_generation - hydro_spill\n        hydro_generation + thermal_generation == 150\n    end)\n    return subproblem\nend","category":"page"},{"location":"tutorial/01_first_steps/#Objective-function","page":"Basic I: first steps","title":"Objective function","text":"","category":"section"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"Finally, we need to add an objective function using @stageobjective. The objective of the agent is to minimize the cost of thermal generation. This is complicated by a fuel cost that depends on the node.","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"One possibility is to use an if statement on node to define the correct objective:","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"function subproblem_builder(subproblem::Model, node::Int)\n    # State variables\n    @variable(subproblem, 0 <= volume <= 200, SDDP.State, initial_value = 200)\n    # Control variables\n    @variables(subproblem, begin\n        thermal_generation >= 0\n        hydro_generation   >= 0\n        hydro_spill        >= 0\n    end)\n    # Transition function and constraints\n    @constraints(subproblem, begin\n        volume.out == volume.in - hydro_generation - hydro_spill\n        hydro_generation + thermal_generation == 150\n    end)\n    # Stage-objective\n    if node == 1\n        @stageobjective(subproblem, 50 * thermal_generation)\n    elseif node == 2\n        @stageobjective(subproblem, 100 * thermal_generation)\n    else\n        @assert node == 3\n        @stageobjective(subproblem, 150 * thermal_generation)\n    end\n    return subproblem\nend","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"A second possibility is to use an array of fuel costs, and use node to index the correct value:","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"function subproblem_builder(subproblem::Model, node::Int)\n    # State variables\n    @variable(subproblem, 0 <= volume <= 200, SDDP.State, initial_value = 200)\n    # Control variables\n    @variables(subproblem, begin\n        thermal_generation >= 0\n        hydro_generation   >= 0\n        hydro_spill        >= 0\n    end)\n    # Transition function and constraints\n    @constraints(subproblem, begin\n        volume.out == volume.in - hydro_generation - hydro_spill\n        hydro_generation + thermal_generation == 150\n    end)\n    # Stage-objective\n    fuel_cost = [50, 100, 150]\n    @stageobjective(subproblem, fuel_cost[node] * thermal_generation)\n    return subproblem\nend","category":"page"},{"location":"tutorial/01_first_steps/#Contructing-the-model","page":"Basic I: first steps","title":"Contructing the model","text":"","category":"section"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"Now that we've written our subproblem, we need to contruct the full model. For that, we're going to need a linear solver. Let's choose GLPK:","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"using GLPK","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"Then, we can create a full model using SDDP.PolicyGraph, passing our subproblem_builder function as the first argument, and our graph as the second:","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"model = SDDP.PolicyGraph(\n    subproblem_builder,\n    graph;\n    sense = :Min,\n    lower_bound = 0.0,\n    optimizer = GLPK.Optimizer,\n)","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"Hopefully the sense keyword is obvious. However, the other two are not so clear.","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"lower_bound: you must supply a valid bound on the objective. For our problem, we know that we cannot incur a negative cost so \\$0 is a valid lower bound.","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"optimizer: This is borrowed directly from JuMP's Model constructor: (Model(GLPK.Optimizer))","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"Because linear policy graphs are the most commonly used structure, we can use SDDP.LinearPolicyGraph(; stages) instead of passing SDDP.LinearGraph(3) to SDDP.PolicyGraph.","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"model = SDDP.LinearPolicyGraph(\n    subproblem_builder;\n    stages = 3,\n    sense = :Min,\n    lower_bound = 0.0,\n    optimizer = GLPK.Optimizer,\n)","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"Third option is to use Julia's do syntax to avoid needing to define a subproblem_builder function separately:","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"model = SDDP.LinearPolicyGraph(\n    stages = 3,\n    sense = :Min,\n    lower_bound = 0.0,\n    optimizer = GLPK.Optimizer,\n) do subproblem, node\n    # State variables\n    @variable(subproblem, 0 <= volume <= 200, SDDP.State, initial_value = 200)\n    # Control variables\n    @variables(subproblem, begin\n        thermal_generation >= 0\n        hydro_generation   >= 0\n        hydro_spill        >= 0\n    end)\n    # Transition function and constraints\n    @constraints(subproblem, begin\n        volume.out == volume.in - hydro_generation - hydro_spill\n        hydro_generation + thermal_generation == 150\n    end)\n    # Stage-objective\n    if node == 1\n        @stageobjective(subproblem, 50 * thermal_generation)\n    elseif node == 2\n        @stageobjective(subproblem, 100 * thermal_generation)\n    else\n        @assert node == 3\n        @stageobjective(subproblem, 150 * thermal_generation)\n    end\nend","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"info: Info\nJulia's do syntax is just a different way of passing an anonymous function inner to some function outer which takes inner as the first argument. For example, given:outer(inner::Function, x, y) = inner(x, y)thenouter(1, 2) do x, y\n    return x^2 + y^2\nendis equivalent to:outer((x, y) -> x^2 + y^2, 1, 2)For our purpose, inner is subproblem_builder, and outer is SDDP.PolicyGraph.","category":"page"},{"location":"tutorial/01_first_steps/#Training-a-policy","page":"Basic I: first steps","title":"Training a policy","text":"","category":"section"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"Now we have a model, which is a description of the policy graph, we need to train a policy. Models can be trained using the SDDP.train function. It accepts a number of keyword arguments. iteration_limit terminates the training after the provided number of iterations.","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"SDDP.train(model; iteration_limit = 3)","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"tip: Tip\nFor more information on the numerical stability report, read the Numerical stability report section.","category":"page"},{"location":"tutorial/01_first_steps/#Obtaining-the-decision-rule","page":"Basic I: first steps","title":"Obtaining the decision rule","text":"","category":"section"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"After training a policy, we can create a decision rule using SDDP.DecisionRule:","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"rule = SDDP.DecisionRule(model; node = 1)","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"Then, to evalute the decision rule, we use SDDP.evaluate:","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"solution = SDDP.evaluate(\n    rule;\n    incoming_state = Dict(:volume => 150.0),\n    controls_to_record = [:hydro_generation, :thermal_generation],\n)","category":"page"},{"location":"tutorial/01_first_steps/#Simulating-the-policy","page":"Basic I: first steps","title":"Simulating the policy","text":"","category":"section"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"Once you have a trained policy, you can also simulate it using SDDP.simulate. The return value from simulate is a vector with one element for each replication. Each element is itself a vector, with one element for each stage. Each element, corresponding to a particular stage in a particular replication, is a dictionary that records information from the simulation.","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"simulations = SDDP.simulate(\n    # The trained model to simulate.\n    model,\n    # The number of replications.\n    1,\n    # A list of names to record the values of.\n    [:volume, :thermal_generation, :hydro_generation, :hydro_spill]\n)\n\nreplication = 1\nstage = 2\nsimulations[replication][stage]","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"Ignore many of the entries for now;  they will be relevant later.","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"One element of iterest is :volume.","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"outgoing_volume = [stage[:volume].out for stage in simulations[1]]","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"Another is :thermal_generation.","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"thermal_generation = [stage[:thermal_generation] for stage in simulations[1]]","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"From this, we can see the optimal policy: in the first stage, use 150 MWh of thermal generation and 0 MWh of hydro generation. In the second stage, use 100 MWh of thermal and 50 MWh of hydro. In the third and final stage, use 0 MWh of thermal and 150 MWh of  hydro.","category":"page"},{"location":"tutorial/01_first_steps/#Extracting-the-water-values","page":"Basic I: first steps","title":"Extracting the water values","text":"","category":"section"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"Finally, we can use SDDP.ValueFunction and SDDP.evaluate to obtain and evaluate the value function at different points in the state-space.","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"First, we construct a value function from the first subproblem:","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"V = SDDP.ValueFunction(model; node = 1)","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"Then we can evaluate V at a point:","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"cost, price = SDDP.evaluate(V; volume = 10)","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"This returns the cost-to-go (cost), and the gradient of the cost-to-go function with resspect to each state variable. Note that since we are minimizing, the price has a negative sign: each additional unit of water leads to a decrease in the the expected long-run cost.","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"For our example, the value of water at the end of the first stage is \\$150, because each additional unit of water can displace a unit of thermal generation in the final stage when the price is \\$150/MWh.","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"This concludes our first tutorial for SDDP.jl. In the next tutorial, Basic II: adding uncertainty, we will extend this problem by adding uncertainty.","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"","category":"page"},{"location":"tutorial/01_first_steps/","page":"Basic I: first steps","title":"Basic I: first steps","text":"This page was generated using Literate.jl.","category":"page"},{"location":"guides/create_a_general_policy_graph/#Create-a-general-policy-graph","page":"Create a general policy graph","title":"Create a general policy graph","text":"","category":"section"},{"location":"guides/create_a_general_policy_graph/","page":"Create a general policy graph","title":"Create a general policy graph","text":"DocTestSetup = quote\n    using SDDP, GLPK\nend","category":"page"},{"location":"guides/create_a_general_policy_graph/","page":"Create a general policy graph","title":"Create a general policy graph","text":"SDDP.jl uses the concept of a policy graph to formulate multistage stochastic programming problems. We highly recommend that you read the following paper before continuing with this tutorial.","category":"page"},{"location":"guides/create_a_general_policy_graph/","page":"Create a general policy graph","title":"Create a general policy graph","text":"Dowson, O. (2018). The policy graph decomposition of multistage stochastic optimization problems. Optimization Online. link","category":"page"},{"location":"guides/create_a_general_policy_graph/#Creating-a-[SDDP.Graph](@ref)","page":"Create a general policy graph","title":"Creating a SDDP.Graph","text":"","category":"section"},{"location":"guides/create_a_general_policy_graph/#Linear-graphs","page":"Create a general policy graph","title":"Linear graphs","text":"","category":"section"},{"location":"guides/create_a_general_policy_graph/","page":"Create a general policy graph","title":"Create a general policy graph","text":"Linear policy graphs can be created using the SDDP.LinearGraph function.","category":"page"},{"location":"guides/create_a_general_policy_graph/","page":"Create a general policy graph","title":"Create a general policy graph","text":"julia> graph = SDDP.LinearGraph(3)\nRoot\n 0\nNodes\n 1\n 2\n 3\nArcs\n 0 => 1 w.p. 1.0\n 1 => 2 w.p. 1.0\n 2 => 3 w.p. 1.0","category":"page"},{"location":"guides/create_a_general_policy_graph/","page":"Create a general policy graph","title":"Create a general policy graph","text":"We can add nodes to a graph using SDDP.add_node and edges using SDDP.add_edge.","category":"page"},{"location":"guides/create_a_general_policy_graph/","page":"Create a general policy graph","title":"Create a general policy graph","text":"julia> SDDP.add_node(graph, 4)\n\njulia> SDDP.add_edge(graph, 3 => 4, 1.0)\n\njulia> SDDP.add_edge(graph, 4 => 1, 0.9)\n\njulia> graph\nRoot\n 0\nNodes\n 1\n 2\n 3\n 4\nArcs\n 0 => 1 w.p. 1.0\n 1 => 2 w.p. 1.0\n 2 => 3 w.p. 1.0\n 3 => 4 w.p. 1.0\n 4 => 1 w.p. 0.9","category":"page"},{"location":"guides/create_a_general_policy_graph/","page":"Create a general policy graph","title":"Create a general policy graph","text":"Look! We just made a cyclic graph! SDDP.jl can solve infinite horizon problems. The probability on the arc that completes a cycle should be interpreted as a discount factor.","category":"page"},{"location":"guides/create_a_general_policy_graph/#Markovian-policy-graphs","page":"Create a general policy graph","title":"Markovian policy graphs","text":"","category":"section"},{"location":"guides/create_a_general_policy_graph/","page":"Create a general policy graph","title":"Create a general policy graph","text":"Markovian policy graphs can be created using the SDDP.MarkovianGraph function.","category":"page"},{"location":"guides/create_a_general_policy_graph/","page":"Create a general policy graph","title":"Create a general policy graph","text":"julia> SDDP.MarkovianGraph(Matrix{Float64}[[1.0]', [0.4 0.6]])\nRoot\n (0, 1)\nNodes\n (1, 1)\n (2, 1)\n (2, 2)\nArcs\n (0, 1) => (1, 1) w.p. 1.0\n (1, 1) => (2, 1) w.p. 0.4\n (1, 1) => (2, 2) w.p. 0.6","category":"page"},{"location":"guides/create_a_general_policy_graph/#General-graphs","page":"Create a general policy graph","title":"General graphs","text":"","category":"section"},{"location":"guides/create_a_general_policy_graph/","page":"Create a general policy graph","title":"Create a general policy graph","text":"Arbitrarily complicated graphs can be constructed using SDDP.Graph, SDDP.add_node and SDDP.add_edge. For example","category":"page"},{"location":"guides/create_a_general_policy_graph/","page":"Create a general policy graph","title":"Create a general policy graph","text":"julia> graph = SDDP.Graph(:root_node)\nRoot\n root_node\nNodes\nArcs\n\njulia> SDDP.add_node(graph, :decision_node)\n\njulia> SDDP.add_edge(graph, :root_node => :decision_node, 1.0)\n\njulia> SDDP.add_edge(graph, :decision_node => :decision_node, 0.9)\n\njulia> graph\nRoot\n root_node\nNodes\n decision_node\nArcs\n root_node => decision_node w.p. 1.0\n decision_node => decision_node w.p. 0.9","category":"page"},{"location":"guides/create_a_general_policy_graph/#Creating-a-policy-graph","page":"Create a general policy graph","title":"Creating a policy graph","text":"","category":"section"},{"location":"guides/create_a_general_policy_graph/","page":"Create a general policy graph","title":"Create a general policy graph","text":"Once you have constructed an instance of [SDDP.Graph], you can create a policy graph by passing the graph as the first argument.","category":"page"},{"location":"guides/create_a_general_policy_graph/","page":"Create a general policy graph","title":"Create a general policy graph","text":"julia> graph = SDDP.Graph(\n           :root_node,\n           [:decision_node],\n           [\n               (:root_node => :decision_node, 1.0),\n               (:decision_node => :decision_node, 0.9)\n           ]);\n\njulia> model = SDDP.PolicyGraph(\n               graph,\n               lower_bound = 0,\n               optimizer = GLPK.Optimizer) do subproblem, node\n           println(\"Called from node: \", node)\n       end;\nCalled from node: decision_node","category":"page"},{"location":"guides/create_a_general_policy_graph/#Special-cases","page":"Create a general policy graph","title":"Special cases","text":"","category":"section"},{"location":"guides/create_a_general_policy_graph/","page":"Create a general policy graph","title":"Create a general policy graph","text":"There are two special cases which cover the majority of models in the literature.","category":"page"},{"location":"guides/create_a_general_policy_graph/","page":"Create a general policy graph","title":"Create a general policy graph","text":"SDDP.LinearPolicyGraph is a special case where a SDDP.LinearGraph is passed as the first argument.\nSDDP.MarkovianPolicyGraph is a special case where a SDDP.MarkovianGraph is passed as the first argument.","category":"page"},{"location":"guides/create_a_general_policy_graph/","page":"Create a general policy graph","title":"Create a general policy graph","text":"Note that the type of the names of all nodes (including the root node) must be the same. In this case, they are Symbols.","category":"page"},{"location":"guides/create_a_general_policy_graph/#Simulating-non-standard-policy-graphs","page":"Create a general policy graph","title":"Simulating non-standard policy graphs","text":"","category":"section"},{"location":"guides/create_a_general_policy_graph/","page":"Create a general policy graph","title":"Create a general policy graph","text":"If you simulate a policy graph with a node that has outgoing arcs that sum to less than one, you will end up with simulations of different lengths. (The most common case is an infinite horizon stochastic program, aka a linear policy graph with a single cycle.)","category":"page"},{"location":"guides/create_a_general_policy_graph/","page":"Create a general policy graph","title":"Create a general policy graph","text":"To simulate a fixed number of stages, use:","category":"page"},{"location":"guides/create_a_general_policy_graph/","page":"Create a general policy graph","title":"Create a general policy graph","text":"simulations = SDDP.simulate(\n    model,\n    1,\n    sampling_scheme = SDDP.InSampleMonteCarlo(\n        max_depth = 10,\n        terminate_on_dummy_leaf = false\n    )\n)","category":"page"},{"location":"guides/create_a_general_policy_graph/","page":"Create a general policy graph","title":"Create a general policy graph","text":"Here, max_depth controls the number of stages, and terminate_on_dummy_leaf = false stops us from terminating early.","category":"page"},{"location":"guides/create_a_general_policy_graph/","page":"Create a general policy graph","title":"Create a general policy graph","text":"See also Simulate using a different sampling scheme.","category":"page"},{"location":"guides/create_a_general_policy_graph/#Creating-a-Markovian-graph-automatically","page":"Create a general policy graph","title":"Creating a Markovian graph automatically","text":"","category":"section"},{"location":"guides/create_a_general_policy_graph/","page":"Create a general policy graph","title":"Create a general policy graph","text":"SDDP.jl can create a Markovian graph by automatically discretizing a one-dimensional stochastic process and fitting a Markov chain.","category":"page"},{"location":"guides/create_a_general_policy_graph/","page":"Create a general policy graph","title":"Create a general policy graph","text":"To access this functionality, pass a function that takes no arguments and returns a Vector{Float64} to SDDP.MarkovianGraph. To keyword arguments also need to be provided: budget is the total number of nodes in the Markovian graph, and scenarios is the number of realizations of the simulator function used to approximate the graph.","category":"page"},{"location":"guides/create_a_general_policy_graph/","page":"Create a general policy graph","title":"Create a general policy graph","text":"In some cases, scenarios may be too small to provide a reasonable fit of the stochastic process. If so, SDDP.jl will automatically try to re-fit the Markov chain using more scenarios.","category":"page"},{"location":"guides/create_a_general_policy_graph/","page":"Create a general policy graph","title":"Create a general policy graph","text":"function simulator()\n    scenario = zeros(5)\n    for i = 2:5\n        scenario[i] = scenario[i - 1] + rand() - 0.5\n    end\n    return scenario\nend\n\nmodel = SDDP.PolicyGraph(\n    SDDP.MarkovianGraph(simulator; budget = 10, scenarios = 100),\n    sense = :Max,\n    upper_bound = 1e3\n) do subproblem, node\n    (stage, price) = node\n    @variable(subproblem, x >= 0, SDDP.State, initial_value = 1)\n    @constraint(subproblem, x.out <= x.in)\n    @stageobjective(subproblem, price * x.out)\nend","category":"page"},{"location":"guides/debug_a_model/#Debug-a-model","page":"Debug a model","title":"Debug a model","text":"","category":"section"},{"location":"guides/debug_a_model/","page":"Debug a model","title":"Debug a model","text":"Building multistage stochastic programming models is hard. There are a lot of different pieces that need to be put together, and we typically have no idea of the optimal policy, so it can be hard (impossible?) to validate the solution.","category":"page"},{"location":"guides/debug_a_model/","page":"Debug a model","title":"Debug a model","text":"That said, here are a few tips to verify and validate models built using SDDP.jl.","category":"page"},{"location":"guides/debug_a_model/#Writing-subproblems-to-file","page":"Debug a model","title":"Writing subproblems to file","text":"","category":"section"},{"location":"guides/debug_a_model/","page":"Debug a model","title":"Debug a model","text":"The first step to debug a model is to write out the subproblems to a file in order to check that you are actually building what you think you are building.","category":"page"},{"location":"guides/debug_a_model/","page":"Debug a model","title":"Debug a model","text":"This can be achieved with the help of two functions: SDDP.parameterize and SDDP.write_subproblem_to_file. The first lets you parameterize a node given a noise, and the second writes out the subproblem to a file.","category":"page"},{"location":"guides/debug_a_model/","page":"Debug a model","title":"Debug a model","text":"Here is an example model:","category":"page"},{"location":"guides/debug_a_model/","page":"Debug a model","title":"Debug a model","text":"using SDDP, GLPK\n\nmodel = SDDP.LinearPolicyGraph(\n            stages = 2,\n            lower_bound = 0.0,\n            optimizer = GLPK.Optimizer,\n            direct_mode = false\n        ) do subproblem, t\n    @variable(subproblem, x, SDDP.State, initial_value = 1)\n    @variable(subproblem, y)\n    @constraint(subproblem, balance, x.in == x.out + y)\n    SDDP.parameterize(subproblem, [1.1, 2.2]) do ω\n        @stageobjective(subproblem, ω * x.out)\n        JuMP.fix(y, ω)\n    end\nend\n\n# output\n\nA policy graph with 2 nodes.\n Node indices: 1, 2","category":"page"},{"location":"guides/debug_a_model/","page":"Debug a model","title":"Debug a model","text":"Initially, model hasn't been parameterized with a concrete realizations of ω. Let's do so now by parameterizing the first subproblem with ω=1.1.","category":"page"},{"location":"guides/debug_a_model/","page":"Debug a model","title":"Debug a model","text":"julia> SDDP.parameterize(model[1], 1.1)","category":"page"},{"location":"guides/debug_a_model/","page":"Debug a model","title":"Debug a model","text":"Easy! To parameterize the second stage problem, we would have used model[2].","category":"page"},{"location":"guides/debug_a_model/","page":"Debug a model","title":"Debug a model","text":"Now to write out the problem to a file. We'll get a few warnings because some variables and constraints don't have names. They don't matter, so ignore them.","category":"page"},{"location":"guides/debug_a_model/","page":"Debug a model","title":"Debug a model","text":"julia> SDDP.write_subproblem_to_file(model[1], \"subproblem.lp\")\n\njulia> read(\"subproblem.lp\") |> String |> print\nminimize\nobj: 1.1 x_out + 1 x2\nsubject to\nbalance: -1 y + 1 x_in - 1 x_out = 0\nBounds\nx2 >= 0\ny = 1.1\nx_in free\nx_out free\nEnd","category":"page"},{"location":"guides/debug_a_model/","page":"Debug a model","title":"Debug a model","text":"It is easy to see that ω has been set in the objective, and as the fixed value for y.","category":"page"},{"location":"guides/debug_a_model/","page":"Debug a model","title":"Debug a model","text":"It is also possible to parameterize the subproblems using values for ω that are not in the original problem formulation.","category":"page"},{"location":"guides/debug_a_model/","page":"Debug a model","title":"Debug a model","text":"julia> SDDP.parameterize(model[1], 3.3)\n\njulia> SDDP.write_subproblem_to_file(model[1], \"subproblem.lp\")\n\njulia> read(\"subproblem.lp\") |> String |> print\nminimize\nobj: 3.3 x_out + 1 x2\nsubject to\nbalance: -1 y + 1 x_in - 1 x_out = 0\nBounds\nx2 >= 0\ny = 3.3\nx_in free\nx_out free\nEnd\n\njulia> rm(\"subproblem.lp\")  # Clean up.","category":"page"},{"location":"guides/debug_a_model/#Solve-the-determinstic-equivalent","page":"Debug a model","title":"Solve the determinstic equivalent","text":"","category":"section"},{"location":"guides/debug_a_model/","page":"Debug a model","title":"Debug a model","text":"Sometimes, it can be helpful to solve the deterministic equivalent of a problem in order to obtain an exact solution to the problem. To obtain a JuMP model that represents the deterministic equivalent, use SDDP.deterministic_equivalent. The returned model is just a normal JuMP model. Use JuMP to optimize it and query the solution.","category":"page"},{"location":"guides/debug_a_model/","page":"Debug a model","title":"Debug a model","text":"julia> det_equiv = SDDP.deterministic_equivalent(model, GLPK.Optimizer)\nA JuMP Model\nFeasibility problem with:\nVariables: 24\n`GenericAffExpr{Float64,VariableRef}`-in-`MathOptInterface.EqualTo{Float64}`: 10 constraints\n`VariableRef`-in-`MathOptInterface.EqualTo{Float64}`: 8 constraints\n`VariableRef`-in-`MathOptInterface.GreaterThan{Float64}`: 6 constraints\n`VariableRef`-in-`MathOptInterface.LessThan{Float64}`: 4 constraints\nModel mode: AUTOMATIC\nCachingOptimizer state: EMPTY_OPTIMIZER\nSolver name: GLPK\n\njulia> optimize!(det_equiv)\n\njulia> objective_value(det_equiv)\n-5.472500000000001","category":"page"},{"location":"guides/debug_a_model/","page":"Debug a model","title":"Debug a model","text":"warning: Warning\nThe determinstic equivalent scales poorly with problem size. Only use this on small problems!","category":"page"},{"location":"tutorial/03_objective_uncertainty/","page":"Basic III: objective uncertainty","title":"Basic III: objective uncertainty","text":"EditURL = \"https://github.com/odow/SDDP.jl/blob/master/docs/src/tutorial/03_objective_uncertainty.jl\"","category":"page"},{"location":"tutorial/03_objective_uncertainty/#Basic-III:-objective-uncertainty","page":"Basic III: objective uncertainty","title":"Basic III: objective uncertainty","text":"","category":"section"},{"location":"tutorial/03_objective_uncertainty/","page":"Basic III: objective uncertainty","title":"Basic III: objective uncertainty","text":"In the previous tutorial, Basic II: adding uncertainty, we created a stochastic hydro-thermal scheduling model. In this tutorial, we extend the problem by adding uncertainty to the fuel costs.","category":"page"},{"location":"tutorial/03_objective_uncertainty/","page":"Basic III: objective uncertainty","title":"Basic III: objective uncertainty","text":"Previously, we assumed that the fuel cost was deterministic: \\$50/MWh in the first stage, \\$100/MWh in the second stage, and \\$150/MWh in the third stage. For this tutorial, we assume that in addition to these base costs, the actual fuel cost is correlated with the inflows.","category":"page"},{"location":"tutorial/03_objective_uncertainty/","page":"Basic III: objective uncertainty","title":"Basic III: objective uncertainty","text":"Our new model for the uncertinty is given by the following table:","category":"page"},{"location":"tutorial/03_objective_uncertainty/","page":"Basic III: objective uncertainty","title":"Basic III: objective uncertainty","text":"ω 1 2 3\nP(ω) 1/3 1/3 1/3\ninflow 0 50 100\nfuel_multiplier 1.5 1.0 0.75","category":"page"},{"location":"tutorial/03_objective_uncertainty/","page":"Basic III: objective uncertainty","title":"Basic III: objective uncertainty","text":"In stage t, the objective is now to minimize:","category":"page"},{"location":"tutorial/03_objective_uncertainty/","page":"Basic III: objective uncertainty","title":"Basic III: objective uncertainty","text":"fuel_multiplier * fuel_cost[t] * thermal_generation","category":"page"},{"location":"tutorial/03_objective_uncertainty/#Creating-a-model","page":"Basic III: objective uncertainty","title":"Creating a model","text":"","category":"section"},{"location":"tutorial/03_objective_uncertainty/","page":"Basic III: objective uncertainty","title":"Basic III: objective uncertainty","text":"To add an uncertain objective, we can simply call @stageobjective from inside the SDDP.parameterize function.","category":"page"},{"location":"tutorial/03_objective_uncertainty/","page":"Basic III: objective uncertainty","title":"Basic III: objective uncertainty","text":"using SDDP, GLPK\n\nmodel = SDDP.LinearPolicyGraph(\n    stages = 3,\n    sense = :Min,\n    lower_bound = 0.0,\n    optimizer = GLPK.Optimizer\n) do subproblem, t\n    # Define the state variable.\n    @variable(subproblem, 0 <= volume <= 200, SDDP.State, initial_value = 200)\n    # Define the control variables.\n    @variables(subproblem, begin\n        thermal_generation >= 0\n        hydro_generation   >= 0\n        hydro_spill        >= 0\n        inflow\n    end)\n    # Define the constraints\n    @constraints(subproblem, begin\n        volume.out == volume.in + inflow - hydro_generation - hydro_spill\n        thermal_generation + hydro_generation == 150.0\n    end)\n    fuel_cost = [50.0, 100.0, 150.0]\n    # Parameterize the subproblem.\n    Ω = [\n        (inflow = 0.0, fuel_multiplier = 1.5),\n        (inflow = 50.0, fuel_multiplier = 1.0),\n        (inflow = 100.0, fuel_multiplier = 0.75)\n    ]\n    SDDP.parameterize(subproblem, Ω, [1/3, 1/3, 1/3]) do ω\n        JuMP.fix(inflow, ω.inflow)\n        @stageobjective(subproblem,\n            ω.fuel_multiplier * fuel_cost[t] * thermal_generation\n        )\n    end\nend","category":"page"},{"location":"tutorial/03_objective_uncertainty/#Training-and-simulating-the-policy","page":"Basic III: objective uncertainty","title":"Training and simulating the policy","text":"","category":"section"},{"location":"tutorial/03_objective_uncertainty/","page":"Basic III: objective uncertainty","title":"Basic III: objective uncertainty","text":"As in the previous two tutorials, we train and simulate the policy:","category":"page"},{"location":"tutorial/03_objective_uncertainty/","page":"Basic III: objective uncertainty","title":"Basic III: objective uncertainty","text":"SDDP.train(model; iteration_limit = 10)\n\nsimulations = SDDP.simulate(model, 500)\n\nobjective_values = [\n    sum(stage[:stage_objective] for stage in sim) for sim in simulations\n]\n\nusing Statistics\n\nμ = round(mean(objective_values), digits = 2)\nci = round(1.96 * std(objective_values) / sqrt(500), digits = 2)\n\nprintln(\"Confidence interval: \", μ, \" ± \", ci)\nprintln(\"Lower bound: \", round(SDDP.calculate_bound(model), digits = 2))","category":"page"},{"location":"tutorial/03_objective_uncertainty/","page":"Basic III: objective uncertainty","title":"Basic III: objective uncertainty","text":"This concludes our third tutorial for SDDP.jl. In the next tutorial, Basic IV: Markov uncertainty, we add stagewise-dependence to the inflows using a Markov chain.","category":"page"},{"location":"tutorial/03_objective_uncertainty/","page":"Basic III: objective uncertainty","title":"Basic III: objective uncertainty","text":"","category":"page"},{"location":"tutorial/03_objective_uncertainty/","page":"Basic III: objective uncertainty","title":"Basic III: objective uncertainty","text":"This page was generated using Literate.jl.","category":"page"},{"location":"guides/upgrade_from_the_old_sddp/#Upgrade-from-the-old-SDDP.jl","page":"Upgrade from the old SDDP.jl","title":"Upgrade from the old SDDP.jl","text":"","category":"section"},{"location":"guides/upgrade_from_the_old_sddp/","page":"Upgrade from the old SDDP.jl","title":"Upgrade from the old SDDP.jl","text":"SDDP.jl under went a major re-write to be compatible with JuMP v0.19 and Julia v1.0.","category":"page"},{"location":"guides/upgrade_from_the_old_sddp/","page":"Upgrade from the old SDDP.jl","title":"Upgrade from the old SDDP.jl","text":"Some of the highlights of the new release include","category":"page"},{"location":"guides/upgrade_from_the_old_sddp/","page":"Upgrade from the old SDDP.jl","title":"Upgrade from the old SDDP.jl","text":"Support for \"multi-cut\"s\nSupport for stagewise-independent noise in the constraint matrix\nA way to simulate out-of-sample realizations of the stagewise-independent noise terms\nExtensible ways to get information such as dual variables out of a simulation\nSupport for infinite horizon multistage stochastic programs\nExtensible stopping rules\nExtensible sampling schemes\nImproved cut selection routines\nBetter checks for numerical issues\nA much tidier (and simpler) implementation, with ample commenting throughout the code base","category":"page"},{"location":"guides/upgrade_from_the_old_sddp/#Syntax-changes","page":"Upgrade from the old SDDP.jl","title":"Syntax changes","text":"","category":"section"},{"location":"guides/upgrade_from_the_old_sddp/","page":"Upgrade from the old SDDP.jl","title":"Upgrade from the old SDDP.jl","text":"The complete re-write has resulted in a painful upgrading process as users must simultaneously upgrade from Julia 0.6 to Julia 1.0, from JuMP 0.18 to JuMP 0.19, and from the old syntax of SDDP.jl to the new. In this section, we outline some of the larger changes. For more information, we recommend reading the updated tutorials, beginning with Basic I: first steps","category":"page"},{"location":"guides/upgrade_from_the_old_sddp/#SDDPModel","page":"Upgrade from the old SDDP.jl","title":"SDDPModel","text":"","category":"section"},{"location":"guides/upgrade_from_the_old_sddp/","page":"Upgrade from the old SDDP.jl","title":"Upgrade from the old SDDP.jl","text":"SDDPModel has been replaced in favor of a more general approach to formulating multistage stochastic optimization problems.","category":"page"},{"location":"guides/upgrade_from_the_old_sddp/","page":"Upgrade from the old SDDP.jl","title":"Upgrade from the old SDDP.jl","text":"For basic use-cases, SDDPModel has been replaced by LinearPolicyGraph.","category":"page"},{"location":"guides/upgrade_from_the_old_sddp/","page":"Upgrade from the old SDDP.jl","title":"Upgrade from the old SDDP.jl","text":"model = SDDPModel(stages = 3) do subproblem, t\n    # subproblem definition.\nend\n\n# becomes\n\nmodel = SDDP.LinearPolicyGraph(stages = 3) do subproblem, t\n    # subproblem definition.\nend","category":"page"},{"location":"guides/upgrade_from_the_old_sddp/","page":"Upgrade from the old SDDP.jl","title":"Upgrade from the old SDDP.jl","text":"If you used the markov_transition feature, SDDPModel has been replaced by MarkovianPolicyGraph.","category":"page"},{"location":"guides/upgrade_from_the_old_sddp/","page":"Upgrade from the old SDDP.jl","title":"Upgrade from the old SDDP.jl","text":"model = SDDPModel(\n      markov_transition = Array{Float64, 2}[\n          [ 1.0 ]',\n          [ 0.75 0.25 ],\n          [ 0.75 0.25 ; 0.25 0.75 ]\n      ]) do subproblem, t, i\n  # subproblem definition.\nend\n\n# becomes\n\nmodel = SDDP.MarkovianPolicyGraph(\n        transition_matrices = Array{Float64, 2}[\n            [ 1.0 ]',\n            [ 0.75 0.25 ],\n            [ 0.75 0.25 ; 0.25 0.75 ]\n        ]) do subproblem, node\n    t, i = node\n    # subproblem definition.\nend","category":"page"},{"location":"guides/upgrade_from_the_old_sddp/#solver","page":"Upgrade from the old SDDP.jl","title":"solver =","text":"","category":"section"},{"location":"guides/upgrade_from_the_old_sddp/","page":"Upgrade from the old SDDP.jl","title":"Upgrade from the old SDDP.jl","text":"JuMP 0.19 changed the way that solvers are passed to JuMP models.","category":"page"},{"location":"guides/upgrade_from_the_old_sddp/","page":"Upgrade from the old SDDP.jl","title":"Upgrade from the old SDDP.jl","text":"SDDPModel(solver = GurobiSolver(OutputFlag = 0))\n\n# becomes\n\nLinearPolicyGraph(optimizer = with_optimizer(Gurobi.Optimizer, OutputFlag = 0))","category":"page"},{"location":"guides/upgrade_from_the_old_sddp/#@state","page":"Upgrade from the old SDDP.jl","title":"@state","text":"","category":"section"},{"location":"guides/upgrade_from_the_old_sddp/","page":"Upgrade from the old SDDP.jl","title":"Upgrade from the old SDDP.jl","text":"We changed how to specify state variables.","category":"page"},{"location":"guides/upgrade_from_the_old_sddp/","page":"Upgrade from the old SDDP.jl","title":"Upgrade from the old SDDP.jl","text":"@state(subproblem, 0 <= x <= 1, x0==2)\n\n# becomes\n\n@variable(subproblem, 0 <= x <= 1, SDDP.State, initial_value = 2)","category":"page"},{"location":"guides/upgrade_from_the_old_sddp/","page":"Upgrade from the old SDDP.jl","title":"Upgrade from the old SDDP.jl","text":"In addition, instead of having to create an incoming state x0 and an outgoing state x, we now refer to x.in and x.out. Here is another example:","category":"page"},{"location":"guides/upgrade_from_the_old_sddp/","page":"Upgrade from the old SDDP.jl","title":"Upgrade from the old SDDP.jl","text":"@state(subproblem, 0 <= x[i=1:2] <= 1, x0==i)\n\n# becomes\n\n@variable(subproblem, 0 <= x[i=1:2] <= 1, SDDP.State, initial_value = i)","category":"page"},{"location":"guides/upgrade_from_the_old_sddp/","page":"Upgrade from the old SDDP.jl","title":"Upgrade from the old SDDP.jl","text":"x0[1]\n\n# becomes\n\nx[1].in","category":"page"},{"location":"guides/upgrade_from_the_old_sddp/","page":"Upgrade from the old SDDP.jl","title":"Upgrade from the old SDDP.jl","text":"x[2]\n\n# becomes\n\nx[2].out","category":"page"},{"location":"guides/upgrade_from_the_old_sddp/#@rhsnoise","page":"Upgrade from the old SDDP.jl","title":"@rhsnoise","text":"","category":"section"},{"location":"guides/upgrade_from_the_old_sddp/","page":"Upgrade from the old SDDP.jl","title":"Upgrade from the old SDDP.jl","text":"We removed @rhsnoise. This results in more lines of code, but more flexibility.","category":"page"},{"location":"guides/upgrade_from_the_old_sddp/","page":"Upgrade from the old SDDP.jl","title":"Upgrade from the old SDDP.jl","text":"@rhsnoise(subproblem, ω = [1, 2, 3], 2x <= ω)\nsetnoiseprobability!(subproblem, [0.5, 0.2, 0.3])\n\n# becomes\n\n@variable(subproblem, ω)\n@constraint(subproblem, 2x <= ω)\nSDDP.parameterize(subproblem, [1, 2, 3], [0.5, 0.2, 0.3]) do ϕ\n    JuMP.fix(ω, ϕ)\nend","category":"page"},{"location":"guides/upgrade_from_the_old_sddp/","page":"Upgrade from the old SDDP.jl","title":"Upgrade from the old SDDP.jl","text":"If you had multiple @rhsnoise constraints, use:","category":"page"},{"location":"guides/upgrade_from_the_old_sddp/","page":"Upgrade from the old SDDP.jl","title":"Upgrade from the old SDDP.jl","text":"@rhsnoise(subproblem, ω = [1, 2, 3], 2x <= ω)\n@rhsnoise(subproblem, ω = [4, 5, 6], y >= 3ω)\nsetnoiseprobability!(subproblem, [0.5, 0.2, 0.3])\n\n# becomes\n\n@variable(subproblem, ω[1:2])\n@constraint(subproblem, 2x <= ω[1])\n@constraint(subproblem, y >= 3 * ω[2])\nSDDP.parameterize(subproblem, [(1, 4), (2, 5), (3, 6)], [0.5, 0.2, 0.3]) do ϕ\n    JuMP.fix(ω[1], ϕ[1])\n    JuMP.fix(ω[2], ϕ[2])\nend","category":"page"},{"location":"guides/upgrade_from_the_old_sddp/#@stageobjective","page":"Upgrade from the old SDDP.jl","title":"@stageobjective","text":"","category":"section"},{"location":"guides/upgrade_from_the_old_sddp/","page":"Upgrade from the old SDDP.jl","title":"Upgrade from the old SDDP.jl","text":"@stageobjective no longer accepts a random list of parameters. Use SDDP.parameterize instead.","category":"page"},{"location":"guides/upgrade_from_the_old_sddp/","page":"Upgrade from the old SDDP.jl","title":"Upgrade from the old SDDP.jl","text":"@stageobjective(subproblem, ω = [1, 2, 3], ω * x)\nsetnoiseprobability!(subproblem, [0.5, 0.2, 0.3])\n\n# becomes\n\nSDDP.parameterize(subproblem, [1, 2, 3], [0.5, 0.2, 0.3]) do ω\n    @stageobjective(subproblem, ω * x)\nend","category":"page"},{"location":"guides/upgrade_from_the_old_sddp/#SDDP.solve","page":"Upgrade from the old SDDP.jl","title":"SDDP.solve","text":"","category":"section"},{"location":"guides/upgrade_from_the_old_sddp/","page":"Upgrade from the old SDDP.jl","title":"Upgrade from the old SDDP.jl","text":"SDDP.solve has been replaced by SDDP.train. See the docs for a complete list of the new options as most things have changed.","category":"page"},{"location":"guides/upgrade_from_the_old_sddp/","page":"Upgrade from the old SDDP.jl","title":"Upgrade from the old SDDP.jl","text":"note: Note\nParallel training has not (yet) been implemented.","category":"page"},{"location":"guides/upgrade_from_the_old_sddp/#Plotting","page":"Upgrade from the old SDDP.jl","title":"Plotting","text":"","category":"section"},{"location":"guides/upgrade_from_the_old_sddp/","page":"Upgrade from the old SDDP.jl","title":"Upgrade from the old SDDP.jl","text":"Much of the syntax for plotting has changed. See Basic V: plotting for the new syntax.","category":"page"},{"location":"guides/upgrade_from_the_old_sddp/#Price-interpolation","page":"Upgrade from the old SDDP.jl","title":"Price interpolation","text":"","category":"section"},{"location":"guides/upgrade_from_the_old_sddp/","page":"Upgrade from the old SDDP.jl","title":"Upgrade from the old SDDP.jl","text":"The syntax for models with stagewise-dependent objective processes has completely changed. See Advanced I: objective states for details.","category":"page"},{"location":"tutorial/11_objective_states/","page":"Advanced I: objective states","title":"Advanced I: objective states","text":"EditURL = \"https://github.com/odow/SDDP.jl/blob/master/docs/src/tutorial/11_objective_states.jl\"","category":"page"},{"location":"tutorial/11_objective_states/#Advanced-I:-objective-states","page":"Advanced I: objective states","title":"Advanced I: objective states","text":"","category":"section"},{"location":"tutorial/11_objective_states/","page":"Advanced I: objective states","title":"Advanced I: objective states","text":"There are many applications in which we want to model a price process that follows some auto-regressive process. Common examples include stock prices on financial exchanges and spot-prices in energy markets.","category":"page"},{"location":"tutorial/11_objective_states/","page":"Advanced I: objective states","title":"Advanced I: objective states","text":"However, it is well known that these cannot be incorporated in to SDDP because they result in cost-to-go functions that are convex with respect to some state variables (e.g., the reservoir levels) and concave with respect to other state variables (e.g., the spot price in the current stage).","category":"page"},{"location":"tutorial/11_objective_states/","page":"Advanced I: objective states","title":"Advanced I: objective states","text":"To overcome this problem, the approach in the literature has been to discretize the price process in order to model it using a Markovian policy graph like those discussed in Basic IV: Markov uncertainty.","category":"page"},{"location":"tutorial/11_objective_states/","page":"Advanced I: objective states","title":"Advanced I: objective states","text":"However, recent work offers a way to include stagewise-dependent objective uncertainty into the objective function of SDDP subproblems. Readers are directed to the following works for an introduction:","category":"page"},{"location":"tutorial/11_objective_states/","page":"Advanced I: objective states","title":"Advanced I: objective states","text":"Downward, A., Dowson, O., and Baucke, R. (2017). Stochastic dual dynamic programming with stagewise dependent objective uncertainty. Optimization Online. link\nDowson, O. PhD Thesis. University of Auckland, 2018. link","category":"page"},{"location":"tutorial/11_objective_states/","page":"Advanced I: objective states","title":"Advanced I: objective states","text":"The method discussed in the above works introduces the concept of an objective state into SDDP. Unlike normal state variables in SDDP (e.g., the volume of water in the reservoir), the cost-to-go function is concave with respect to the objective states. Thus, the method builds an outer approximation of the cost-to-go function in the normal state-space, and an inner approximation of the cost-to-go function in the objective state-space.","category":"page"},{"location":"tutorial/11_objective_states/","page":"Advanced I: objective states","title":"Advanced I: objective states","text":"warning: Warning\nSupport for objective states in SDDP.jl is experimental. Models are considerably more computational intensive, the interface is less user-friendly, and there are subtle gotchas to be aware of. Only use this if you have read and understood the theory behind the method.","category":"page"},{"location":"tutorial/11_objective_states/#One-dimensional-objective-states","page":"Advanced I: objective states","title":"One-dimensional objective states","text":"","category":"section"},{"location":"tutorial/11_objective_states/","page":"Advanced I: objective states","title":"Advanced I: objective states","text":"Let's assume that the fuel cost is not fixed, but instead evolves according to a multiplicative auto-regressive process: fuel_cost[t] = ω * fuel_cost[t-1], where ω is drawn from the sample space [0.75, 0.9, 1.1, 1.25] with equal probability.","category":"page"},{"location":"tutorial/11_objective_states/","page":"Advanced I: objective states","title":"Advanced I: objective states","text":"An objective state can be added to a subproblem using the SDDP.add_objective_state function. This can only be called once per subproblem. If you want to add a multi-dimensional objective state, read Multi-dimensional objective states. SDDP.add_objective_state takes a number of keyword arguments. The two required ones are","category":"page"},{"location":"tutorial/11_objective_states/","page":"Advanced I: objective states","title":"Advanced I: objective states","text":"initial_value: the value of the objective state at the root node of the policy graph (i.e., identical to the initial_value when defining normal state variables.\nlipschitz: the Lipschitz constant of the cost-to-go function with respect to the objective state. In other words, this value is the maximum change in the cost-to-go function at any point in the state space, given a one-unit change in the objective state.","category":"page"},{"location":"tutorial/11_objective_states/","page":"Advanced I: objective states","title":"Advanced I: objective states","text":"There are also two optional keyword arguments: lower_bound and upper_bound, which give SDDP.jl hints (importantly, not constraints) about the domain of the objective state. Setting these bounds appropriately can improve the speed of convergence.","category":"page"},{"location":"tutorial/11_objective_states/","page":"Advanced I: objective states","title":"Advanced I: objective states","text":"Finally, SDDP.add_objective_state requires an update function. This function takes two arguments. The first is the incoming value of the objective state, and the second is the realization of the stagewise-independent noise term (set using SDDP.parameterize). The function should return the value of the objective state to be used in the current subproblem.","category":"page"},{"location":"tutorial/11_objective_states/","page":"Advanced I: objective states","title":"Advanced I: objective states","text":"This connection with the stagewise-independent noise term means that SDDP.parameterize must be called in a subproblem that defines an objective state. Inside SDDP.parameterize, the value of the objective state to be used in the current subproblem (i.e., after the update function), can be queried using SDDP.objective_state.","category":"page"},{"location":"tutorial/11_objective_states/","page":"Advanced I: objective states","title":"Advanced I: objective states","text":"Here is the full model with the objective state.","category":"page"},{"location":"tutorial/11_objective_states/","page":"Advanced I: objective states","title":"Advanced I: objective states","text":"using SDDP, GLPK\n\nmodel = SDDP.LinearPolicyGraph(\n    stages = 3,\n    sense = :Min,\n    lower_bound = 0.0,\n    optimizer = GLPK.Optimizer\n) do subproblem, t\n    @variable(subproblem, 0 <= volume <= 200, SDDP.State, initial_value = 200)\n    @variables(subproblem, begin\n        thermal_generation >= 0\n        hydro_generation   >= 0\n        hydro_spill        >= 0\n        inflow\n    end)\n    @constraints(subproblem, begin\n        volume.out == volume.in + inflow - hydro_generation - hydro_spill\n        demand_constraint, thermal_generation + hydro_generation == 150.0\n    end)\n\n    # Add an objective state. ω will be the same value that is called in\n    # `SDDP.parameterize`.\n\n    SDDP.add_objective_state(\n        subproblem,\n        initial_value = 50.0,\n        lipschitz = 10_000.0,\n        lower_bound = 50.0,\n        upper_bound = 150.0\n    ) do fuel_cost, ω\n        return ω.fuel * fuel_cost\n    end\n\n    # Create the cartesian product of a multi-dimensional random variable.\n\n    Ω = [\n        (fuel = f, inflow = w)\n        for f in [0.75, 0.9, 1.1, 1.25] for w in [0.0, 50.0, 100.0]\n    ]\n\n    SDDP.parameterize(subproblem, Ω) do ω\n        # Query the current fuel cost.\n        fuel_cost = SDDP.objective_state(subproblem)\n        @stageobjective(subproblem, fuel_cost * thermal_generation)\n        JuMP.fix(inflow, ω.inflow)\n    end\nend","category":"page"},{"location":"tutorial/11_objective_states/","page":"Advanced I: objective states","title":"Advanced I: objective states","text":"After creating our model, we can train and simulate as usual.","category":"page"},{"location":"tutorial/11_objective_states/","page":"Advanced I: objective states","title":"Advanced I: objective states","text":"SDDP.train(model, iteration_limit = 10, run_numerical_stability_report=false)\n\nsimulations = SDDP.simulate(model, 1)\n\nprint(\"Finished training and simulating.\")","category":"page"},{"location":"tutorial/11_objective_states/","page":"Advanced I: objective states","title":"Advanced I: objective states","text":"To demonstrate how the objective states are updated, consider the sequence of noise observations:","category":"page"},{"location":"tutorial/11_objective_states/","page":"Advanced I: objective states","title":"Advanced I: objective states","text":"[stage[:noise_term] for stage in simulations[1]]","category":"page"},{"location":"tutorial/11_objective_states/","page":"Advanced I: objective states","title":"Advanced I: objective states","text":"This, the fuel cost in the first stage should be 0.75 * 50 = 37.5. The fuel cost in the second stage should be 0.9 * 37.5 = 33.75. The fuel cost in the third stage should be 1.25 * 33.75 = 42.1875.","category":"page"},{"location":"tutorial/11_objective_states/","page":"Advanced I: objective states","title":"Advanced I: objective states","text":"To confirm this, the values of the objective state in a simulation can be queried using the :objective_state key.","category":"page"},{"location":"tutorial/11_objective_states/","page":"Advanced I: objective states","title":"Advanced I: objective states","text":"[stage[:objective_state] for stage in simulations[1]]","category":"page"},{"location":"tutorial/11_objective_states/#Multi-dimensional-objective-states","page":"Advanced I: objective states","title":"Multi-dimensional objective states","text":"","category":"section"},{"location":"tutorial/11_objective_states/","page":"Advanced I: objective states","title":"Advanced I: objective states","text":"You can construct multi-dimensional price processes using NTuples. Just replace every scalar value associated with the objective state by a tuple. For example, initial_value = 1.0 becomes initial_value = (1.0, 2.0).","category":"page"},{"location":"tutorial/11_objective_states/","page":"Advanced I: objective states","title":"Advanced I: objective states","text":"Here is an example:","category":"page"},{"location":"tutorial/11_objective_states/","page":"Advanced I: objective states","title":"Advanced I: objective states","text":"model = SDDP.LinearPolicyGraph(\n    stages = 3,\n    sense = :Min,\n    lower_bound = 0.0,\n    optimizer = GLPK.Optimizer\n) do subproblem, t\n    @variable(subproblem, 0 <= volume <= 200, SDDP.State, initial_value = 200)\n    @variables(subproblem, begin\n        thermal_generation >= 0\n        hydro_generation   >= 0\n        hydro_spill        >= 0\n        inflow\n    end)\n    @constraints(subproblem, begin\n        volume.out == volume.in + inflow - hydro_generation - hydro_spill\n        demand_constraint, thermal_generation + hydro_generation == 150.0\n    end)\n\n    SDDP.add_objective_state(\n        subproblem,\n        initial_value = (50.0, 50.0),\n        lipschitz = (10_000.0, 10_000.0),\n        lower_bound = (50.0, 50.0),\n        upper_bound = (150.0, 150.0)\n    ) do fuel_cost, ω\n        fuel_cost′ = fuel_cost[1] + 0.5 * (fuel_cost[1] - fuel_cost[2]) + ω.fuel\n        return (fuel_cost′, fuel_cost[1])\n    end\n\n    Ω = [\n        (fuel = f, inflow = w)\n        for f in [-10.0, -5.0, 5.0, 10.0] for w in [0.0, 50.0, 100.0]\n    ]\n\n    SDDP.parameterize(subproblem, Ω) do ω\n        (fuel_cost, fuel_cost_old) = SDDP.objective_state(subproblem)\n        @stageobjective(subproblem, fuel_cost * thermal_generation)\n        JuMP.fix(inflow, ω.inflow)\n    end\nend\n\nSDDP.train(model, iteration_limit = 10, run_numerical_stability_report=false)\n\nsimulations = SDDP.simulate(model, 1)\n\nprint(\"Finished training and simulating.\")","category":"page"},{"location":"tutorial/11_objective_states/","page":"Advanced I: objective states","title":"Advanced I: objective states","text":"This time, since our objective state is two-dimensional, the objective states are tuples with two elements:","category":"page"},{"location":"tutorial/11_objective_states/","page":"Advanced I: objective states","title":"Advanced I: objective states","text":"[stage[:objective_state] for stage in simulations[1]]","category":"page"},{"location":"tutorial/11_objective_states/#objective_state_warnings","page":"Advanced I: objective states","title":"Warnings","text":"","category":"section"},{"location":"tutorial/11_objective_states/","page":"Advanced I: objective states","title":"Advanced I: objective states","text":"There are number of things to be aware of when using objective states.","category":"page"},{"location":"tutorial/11_objective_states/","page":"Advanced I: objective states","title":"Advanced I: objective states","text":"The key assumption is that price is independent of the states and actions in the model.\nThat means that the price cannot appear in any @constraints. Nor can you use any @variables in the update function.\nChoosing an appropriate Lipschitz constant is difficult.\nThe points discussed in Choosing an initial bound are relevant. The Lipschitz constant should not be chosen as large as possible (since this will help with convergence and the numerical issues discussed above), but if chosen to small, it may cut of the feasible region and lead to a sub-optimal solution.\nYou need to ensure that the cost-to-go function is concave with respect to the objective state before the update.\nIf the update function is linear, this is always the case. In some situations, the update function can be nonlinear (e.g., multiplicative as we have above). In general, placing constraints on the price (e.g., clamp(price, 0, 1)) will destroy concavity. Caveat emptor. It's up to you if this is a problem. If it isn't you'll get a good heuristic with no guarantee of global optimality.","category":"page"},{"location":"tutorial/11_objective_states/","page":"Advanced I: objective states","title":"Advanced I: objective states","text":"","category":"page"},{"location":"tutorial/11_objective_states/","page":"Advanced I: objective states","title":"Advanced I: objective states","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorial/06_warnings/","page":"Basic VI: words of warning","title":"Basic VI: words of warning","text":"EditURL = \"https://github.com/odow/SDDP.jl/blob/master/docs/src/tutorial/06_warnings.jl\"","category":"page"},{"location":"tutorial/06_warnings/#Basic-VI:-words-of-warning","page":"Basic VI: words of warning","title":"Basic VI: words of warning","text":"","category":"section"},{"location":"tutorial/06_warnings/","page":"Basic VI: words of warning","title":"Basic VI: words of warning","text":"SDDP is a powerful solution technique for multistage stochastic programming. However, there are a number of subtle things to be aware of before creating your own models.","category":"page"},{"location":"tutorial/06_warnings/#Numerical-stability","page":"Basic VI: words of warning","title":"Numerical stability","text":"","category":"section"},{"location":"tutorial/06_warnings/","page":"Basic VI: words of warning","title":"Basic VI: words of warning","text":"If you aren't aware, SDDP builds an outer-approximation to a convex function using cutting planes. This results in a formulation that is particularly hard for solvers like GLPK, Gurobi, and CPLEX to deal with. As a result, you may run into weird behavior. This behavior could include:","category":"page"},{"location":"tutorial/06_warnings/","page":"Basic VI: words of warning","title":"Basic VI: words of warning","text":"Iterations suddenly taking a long time (the solver stalled)\nSubproblems turning infeasible or unbounded after many iterations\nSolvers returning \"Numerical Error\" statuses","category":"page"},{"location":"tutorial/06_warnings/#Attempting-to-recover-from-serious-numerical-issues...","page":"Basic VI: words of warning","title":"Attempting to recover from serious numerical issues...","text":"","category":"section"},{"location":"tutorial/06_warnings/","page":"Basic VI: words of warning","title":"Basic VI: words of warning","text":"SDDP.jl will try hard to avoid and overcome numerical issues. If it encounters issues, you may see the warning Attempting to recover from serious numerical issues.... If you see this warning multiple times, you should try to follow the suggestions in this tutorial to improve the stability of your model.","category":"page"},{"location":"tutorial/06_warnings/#Problem-scaling","page":"Basic VI: words of warning","title":"Problem scaling","text":"","category":"section"},{"location":"tutorial/06_warnings/","page":"Basic VI: words of warning","title":"Basic VI: words of warning","text":"In almost all cases, the cause of this is poor problem scaling. For our purpose, poor problem scaling means having variables with very large numbers and variables with very small numbers in the same model.","category":"page"},{"location":"tutorial/06_warnings/","page":"Basic VI: words of warning","title":"Basic VI: words of warning","text":"tip: Tip\nGurobi has an excellent set of articles on numerical issues and how to avoid them.","category":"page"},{"location":"tutorial/06_warnings/","page":"Basic VI: words of warning","title":"Basic VI: words of warning","text":"Consider, for example, the hydro-thermal scheduling problem we have been discussing in previous tutorials.","category":"page"},{"location":"tutorial/06_warnings/","page":"Basic VI: words of warning","title":"Basic VI: words of warning","text":"If we define the volume of the reservoir in terms of m³, then a lake might have a capacity of 10^10 m³: @variable(subproblem, 0 <= volume <= 10^10). Moreover, the cost per cubic meter might be around \\$0.05/m³. To calculate the  value of water in our reservoir, we need to multiple a variable on the order of 10^10, by one on the order of 10⁻²! That is twelve orders of magnitude!","category":"page"},{"location":"tutorial/06_warnings/","page":"Basic VI: words of warning","title":"Basic VI: words of warning","text":"To improve the performance of the SDDP algorithm (and reduce the chance of weird behavior), try to re-scale the units of the problem in order to reduce the largest difference in magnitude. For example, if we talk in terms of million m³, then we have a capacity of 10⁴ million m³, and a price of \\$50,000 per million m³. Now things are only one order of magnitude apart.","category":"page"},{"location":"tutorial/06_warnings/#Numerical-stability-report","page":"Basic VI: words of warning","title":"Numerical stability report","text":"","category":"section"},{"location":"tutorial/06_warnings/","page":"Basic VI: words of warning","title":"Basic VI: words of warning","text":"To aid in the diagnose of numerical issues, you can call SDDP.numerical_stability_report. By default, this aggregates all of the nodes into a single report. You can produce a stability report for each node by passing by_node=true.","category":"page"},{"location":"tutorial/06_warnings/","page":"Basic VI: words of warning","title":"Basic VI: words of warning","text":"using SDDP\n\nmodel = SDDP.LinearPolicyGraph(\n    stages = 2, lower_bound = -1e10, direct_mode = false\n) do subproblem, t\n    @variable(subproblem, x >= -1e7, SDDP.State, initial_value=1e-5)\n    @constraint(subproblem, 1e9 * x.out >= 1e-6 * x.in + 1e-8)\n    @stageobjective(subproblem, 1e9 * x.out)\nend\n\nSDDP.numerical_stability_report(model)","category":"page"},{"location":"tutorial/06_warnings/","page":"Basic VI: words of warning","title":"Basic VI: words of warning","text":"The report analyses the magnitude (in absolute terms) of the coefficients in the constraint matrix, the objective function, any variable bounds, and in the RHS of the constraints. A warning will be thrown in SDDP.jl detects very large or small values. As discussed in Problem scaling, this is an indication that you should reformulate your model.","category":"page"},{"location":"tutorial/06_warnings/","page":"Basic VI: words of warning","title":"Basic VI: words of warning","text":"By default, a numerical stability check is run when you call SDDP.train, although it can be turned off by passing run_numerical_stability_report = false.","category":"page"},{"location":"tutorial/06_warnings/#Solver-specific-options","page":"Basic VI: words of warning","title":"Solver-specific options","text":"","category":"section"},{"location":"tutorial/06_warnings/","page":"Basic VI: words of warning","title":"Basic VI: words of warning","text":"If you have a particularly troublesome model, you should investigate setting solver-specific options to improve the numerical stability of each solver. For example, Gurobi has a NumericFocus option.","category":"page"},{"location":"tutorial/06_warnings/#Choosing-an-initial-bound","page":"Basic VI: words of warning","title":"Choosing an initial bound","text":"","category":"section"},{"location":"tutorial/06_warnings/","page":"Basic VI: words of warning","title":"Basic VI: words of warning","text":"One of the important requirements when building a SDDP model is to choose an appropriate bound on the objective (lower if minimizing, upper if maximizing). However, it can be hard to choose a bound if you don't know the solution! (Which is very likely.)","category":"page"},{"location":"tutorial/06_warnings/","page":"Basic VI: words of warning","title":"Basic VI: words of warning","text":"The bound should not be as large as possible (since this will help with convergence and the numerical issues discussed above), but if chosen too small, it may cut off the feasible region and lead to a sub-optimal solution.","category":"page"},{"location":"tutorial/06_warnings/","page":"Basic VI: words of warning","title":"Basic VI: words of warning","text":"Consider the following simple model, where we first set lower_bound to 0.0.","category":"page"},{"location":"tutorial/06_warnings/","page":"Basic VI: words of warning","title":"Basic VI: words of warning","text":"using SDDP, GLPK\n\nmodel = SDDP.LinearPolicyGraph(\n    stages = 3,\n    sense = :Min,\n    lower_bound = 0.0,\n    optimizer = GLPK.Optimizer\n) do subproblem, t\n    @variable(subproblem, x >= 0, SDDP.State, initial_value = 2)\n    @variable(subproblem, u >= 0)\n    @variable(subproblem, v >= 0)\n    @constraint(subproblem, x.out == x.in - u)\n    @constraint(subproblem, u + v == 1.5)\n    @stageobjective(subproblem, t * v)\nend\n\nSDDP.train(model, iteration_limit = 5, run_numerical_stability_report = false)","category":"page"},{"location":"tutorial/06_warnings/","page":"Basic VI: words of warning","title":"Basic VI: words of warning","text":"Now consider the case when we set the lower_bound to 10.0:","category":"page"},{"location":"tutorial/06_warnings/","page":"Basic VI: words of warning","title":"Basic VI: words of warning","text":"using SDDP, GLPK\n\nmodel = SDDP.LinearPolicyGraph(\n    stages = 3,\n    sense = :Min,\n    lower_bound = 10.0,\n    optimizer = GLPK.Optimizer\n) do subproblem, t\n    @variable(subproblem, x >= 0, SDDP.State, initial_value = 2)\n    @variable(subproblem, u >= 0)\n    @variable(subproblem, v >= 0)\n    @constraint(subproblem, x.out == x.in - u)\n    @constraint(subproblem, u + v == 1.5)\n    @stageobjective(subproblem, t * v)\nend\n\nSDDP.train(model, iteration_limit = 5, run_numerical_stability_report = false)","category":"page"},{"location":"tutorial/06_warnings/","page":"Basic VI: words of warning","title":"Basic VI: words of warning","text":"How do we tell which is more appropriate? There are a few clues that you should look out for.","category":"page"},{"location":"tutorial/06_warnings/","page":"Basic VI: words of warning","title":"Basic VI: words of warning","text":"The bound converges to a value above (if minimizing) the simulated cost of the policy. In this case, the problem is deterministic, so it is easy to tell. But you can also check by performing a Monte Carlo simulation like we did in Basic II: adding uncertainty.\nThe bound converges to different values when we change the bound. This is another clear give-away. The bound provided by the user is only used in the initial iterations. It should not change the value of the converged policy. Thus, if you don't know an appropriate value for the bound, choose an initial value, and then increase (or decrease) the value of the bound to confirm that the value of the policy doesn't change.\nThe bound converges to a value close to the bound provided by the user. This varies between models, but notice that 11.0 is quite close to 10.0 compared with 3.5 and 0.0.","category":"page"},{"location":"tutorial/06_warnings/","page":"Basic VI: words of warning","title":"Basic VI: words of warning","text":"This concludes our sixth tutorial for SDDP.jl. You're now ready to start solving multistage stochastic programs with SDDP.jl!","category":"page"},{"location":"tutorial/06_warnings/","page":"Basic VI: words of warning","title":"Basic VI: words of warning","text":"","category":"page"},{"location":"tutorial/06_warnings/","page":"Basic VI: words of warning","title":"Basic VI: words of warning","text":"This page was generated using Literate.jl.","category":"page"},{"location":"guides/simulate_using_a_different_sampling_scheme/#Simulate-using-a-different-sampling-scheme","page":"Simulate using a different sampling scheme","title":"Simulate using a different sampling scheme","text":"","category":"section"},{"location":"guides/simulate_using_a_different_sampling_scheme/","page":"Simulate using a different sampling scheme","title":"Simulate using a different sampling scheme","text":"DocTestSetup = quote\n    using SDDP, GLPK\nend","category":"page"},{"location":"guides/simulate_using_a_different_sampling_scheme/","page":"Simulate using a different sampling scheme","title":"Simulate using a different sampling scheme","text":"By default, SDDP.simulate will simulate the policy using the distributions of noise terms that were defined when the model was created. We call these in-sample simulations. However, in general the in-sample distributions are an approximation of some underlying probabiltiy model which we term the true process. Therefore, SDDP.jl makes it easy to simulate the policy using different probability distrutions.","category":"page"},{"location":"guides/simulate_using_a_different_sampling_scheme/","page":"Simulate using a different sampling scheme","title":"Simulate using a different sampling scheme","text":"To demonsrate the different ways of simulating the policy, we're going to use the model from the tutorial Basic IV: Markov uncertainty.","category":"page"},{"location":"guides/simulate_using_a_different_sampling_scheme/","page":"Simulate using a different sampling scheme","title":"Simulate using a different sampling scheme","text":"using SDDP, GLPK\n\nΩ = [\n    (inflow = 0.0, fuel_multiplier = 1.5),\n    (inflow = 50.0, fuel_multiplier = 1.0),\n    (inflow = 100.0, fuel_multiplier = 0.75)\n]\n\nmodel = SDDP.MarkovianPolicyGraph(\n    transition_matrices = Array{Float64, 2}[\n        [ 1.0 ]',\n        [ 0.75 0.25 ],\n        [ 0.75 0.25 ; 0.25 0.75 ]\n    ],\n    sense = :Min,\n    lower_bound = 0.0,\n    optimizer = GLPK.Optimizer\n) do subproblem, node\n    # Unpack the stage and Markov index.\n    t, markov_state = node\n    # Define the state variable.\n    @variable(subproblem, 0 <= volume <= 200, SDDP.State, initial_value = 200)\n    # Define the control variables.\n    @variables(subproblem, begin\n        thermal_generation >= 0\n        hydro_generation   >= 0\n        hydro_spill        >= 0\n        inflow\n    end)\n    # Define the constraints\n    @constraints(subproblem, begin\n        volume.out == volume.in + inflow - hydro_generation - hydro_spill\n        thermal_generation + hydro_generation == 150.0\n    end)\n    # Note how we can use `markov_state` to dispatch an `if` statement.\n    probability = if markov_state == 1  # wet climate state\n        [1/6, 1/3, 1/2]\n    else  # dry climate state\n        [1/2, 1/3, 1/6]\n    end\n\n    fuel_cost = [50.0, 100.0, 150.0]\n    SDDP.parameterize(subproblem, Ω, probability) do ω\n        JuMP.fix(inflow, ω.inflow)\n        @stageobjective(subproblem,\n            ω.fuel_multiplier * fuel_cost[t] * thermal_generation)\n    end\nend\n\nSDDP.train(model; iteration_limit = 10, print_level = 0);\n\nmodel\n\n# output\n\nA policy graph with 5 nodes.\n Node indices: (1, 1), (2, 1), (2, 2), (3, 1), (3, 2)","category":"page"},{"location":"guides/simulate_using_a_different_sampling_scheme/#In-sample-Monte-Carlo-simulation","page":"Simulate using a different sampling scheme","title":"In-sample Monte Carlo simulation","text":"","category":"section"},{"location":"guides/simulate_using_a_different_sampling_scheme/","page":"Simulate using a different sampling scheme","title":"Simulate using a different sampling scheme","text":"To simulate the policy using the data defined when model was created, use SDDP.InSampleMonteCarlo.","category":"page"},{"location":"guides/simulate_using_a_different_sampling_scheme/","page":"Simulate using a different sampling scheme","title":"Simulate using a different sampling scheme","text":"simulations = SDDP.simulate(\n    model, 20, sampling_scheme = SDDP.InSampleMonteCarlo()\n)\n\nsort(unique(\n    [node[:noise_term] for simulation in simulations for node in simulation]\n))\n\n# output\n\n3-element Array{NamedTuple{(:inflow, :fuel_multiplier),Tuple{Float64,Float64}},1}:\n (inflow = 0.0, fuel_multiplier = 1.5)\n (inflow = 50.0, fuel_multiplier = 1.0)\n (inflow = 100.0, fuel_multiplier = 0.75)","category":"page"},{"location":"guides/simulate_using_a_different_sampling_scheme/#Out-of-sample-Monte-Carlo-simulation","page":"Simulate using a different sampling scheme","title":"Out-of-sample Monte Carlo simulation","text":"","category":"section"},{"location":"guides/simulate_using_a_different_sampling_scheme/","page":"Simulate using a different sampling scheme","title":"Simulate using a different sampling scheme","text":"Instead of using the in-sample data, we can perform an out-of-sample simulation of the policy using the SDDP.OutOfSampleMonteCarlo sampling scheme.","category":"page"},{"location":"guides/simulate_using_a_different_sampling_scheme/","page":"Simulate using a different sampling scheme","title":"Simulate using a different sampling scheme","text":"For each node, the SDDP.OutOfSampleMonteCarlo needs to define a new distribution for the transition probabilities between nodes in the policy graph, and a new distribution for the stagewise independent noise terms.","category":"page"},{"location":"guides/simulate_using_a_different_sampling_scheme/","page":"Simulate using a different sampling scheme","title":"Simulate using a different sampling scheme","text":"note: Note\nThe support of the distribution for the stagewise independent noise terms does not have to be the same as the in-sample distributions.","category":"page"},{"location":"guides/simulate_using_a_different_sampling_scheme/","page":"Simulate using a different sampling scheme","title":"Simulate using a different sampling scheme","text":"sampling_scheme = SDDP.OutOfSampleMonteCarlo(model) do node\n    stage, markov_state = node\n    if stage == 0\n        # Called from the root node. Transition to (1, 1) with probability 1.0.\n        # Only return the list of children, _not_ a list of noise terms.\n        return [SDDP.Noise((1, 1), 1.0)]\n    elseif stage == 3\n        # Called from the final node. Return an empty list for the children,\n        # and a single, deterministic realization for the noise terms.\n        children = SDDP.Noise[]\n        noise_terms = [SDDP.Noise((inflow = 75.0, fuel_multiplier = 1.2), 1.0)]\n        return children, noise_terms\n    else\n        # Called from a normal node. Return the in-sample distribution for the\n        # noise terms, but modify the transition probabilities so that the\n        # Markov switching probability is now 50%.\n        probability = markov_state == 1 ? [1/6, 1/3, 1/2] : [1/2, 1/3, 1/6]\n        noise_terms = [SDDP.Noise(ω, p) for (ω, p) in zip(Ω, probability)]\n        children = [\n            SDDP.Noise((stage + 1, 1), 0.5), SDDP.Noise((stage + 1, 2), 0.5)\n        ]\n        return children, noise_terms\n    end\nend\n\nsimulations = SDDP.simulate(model, 1, sampling_scheme = sampling_scheme)\n\nsimulations[1][3][:noise_term]\n\n# output\n\n(inflow = 75.0, fuel_multiplier = 1.2)","category":"page"},{"location":"guides/simulate_using_a_different_sampling_scheme/","page":"Simulate using a different sampling scheme","title":"Simulate using a different sampling scheme","text":"Alternatively, if you only want to modify the stagewise independent noise terms, pass use_insample_transition = true.","category":"page"},{"location":"guides/simulate_using_a_different_sampling_scheme/","page":"Simulate using a different sampling scheme","title":"Simulate using a different sampling scheme","text":"sampling_scheme = SDDP.OutOfSampleMonteCarlo(\n    model, use_insample_transition = true\n) do node\nstage, markov_state = node\n    if stage == 3\n        # Called from the final node. Return a single, deterministic\n        # realization for the noise terms. Don't return the children because we\n        # use the in-sample data.\n        return [SDDP.Noise((inflow = 65.0, fuel_multiplier = 1.1), 1.0)]\n    else\n        # Called from a normal node. Return the in-sample distribution for the\n        # noise terms. Don't return the children because we use the in-sample\n        # data.\n        probability = markov_state == 1 ? [1/6, 1/3, 1/2] : [1/2, 1/3, 1/6]\n        return [SDDP.Noise(ω, p) for (ω, p) in zip(Ω, probability)]\n    end\nend\n\nsimulations = SDDP.simulate(model, 1, sampling_scheme = sampling_scheme)\n\nsimulations[1][3][:noise_term]\n\n# output\n\n(inflow = 65.0, fuel_multiplier = 1.1)","category":"page"},{"location":"guides/simulate_using_a_different_sampling_scheme/#Historical-simulation","page":"Simulate using a different sampling scheme","title":"Historical simulation","text":"","category":"section"},{"location":"guides/simulate_using_a_different_sampling_scheme/","page":"Simulate using a different sampling scheme","title":"Simulate using a different sampling scheme","text":"Instead of performing a Monte Carlo simulation like the previous tutorials, we may want to simulate one particular sequence of noise realizations. This historical simulation can also be conducted by passing a SDDP.Historical sampling scheme to the sampling_scheme keyword of the SDDP.simulate function.","category":"page"},{"location":"guides/simulate_using_a_different_sampling_scheme/","page":"Simulate using a different sampling scheme","title":"Simulate using a different sampling scheme","text":"We can confirm that the historical sequence of nodes was visited by querying the :node_index key of the simulation results.","category":"page"},{"location":"guides/simulate_using_a_different_sampling_scheme/","page":"Simulate using a different sampling scheme","title":"Simulate using a different sampling scheme","text":"simulations = SDDP.simulate(\n    model,\n    sampling_scheme = SDDP.Historical([\n        ((1, 1), Ω[1]),\n        ((2, 2), Ω[3]),\n        ((3, 1), Ω[2])\n    ])\n)\n\n[stage[:node_index] for stage in simulations[1]]\n\n# output\n\n3-element Array{Tuple{Int64,Int64},1}:\n (1, 1)\n (2, 2)\n (3, 1)","category":"page"},{"location":"guides/add_a_multidimensional_state_variable/#Add-a-multi-dimensional-state-variable","page":"Add a multi-dimensional state variable","title":"Add a multi-dimensional state variable","text":"","category":"section"},{"location":"guides/add_a_multidimensional_state_variable/","page":"Add a multi-dimensional state variable","title":"Add a multi-dimensional state variable","text":"DocTestSetup = quote\n    using SDDP, GLPK\nend","category":"page"},{"location":"guides/add_a_multidimensional_state_variable/","page":"Add a multi-dimensional state variable","title":"Add a multi-dimensional state variable","text":"Just like normal JuMP variables, it is possible to create containers of state variables.","category":"page"},{"location":"guides/add_a_multidimensional_state_variable/","page":"Add a multi-dimensional state variable","title":"Add a multi-dimensional state variable","text":"julia> model = SDDP.LinearPolicyGraph(\n           stages=1, lower_bound = 0, optimizer = GLPK.Optimizer\n       ) do subproblem, t\n           # A scalar state variable.\n           @variable(subproblem, x >= 0, SDDP.State, initial_value = 0)\n           println(\"Lower bound of outgoing x is: \", JuMP.lower_bound(x.out))\n           # A vector of state variables.\n           @variable(subproblem, y[i = 1:2] >= i, SDDP.State, initial_value = i)\n           println(\"Lower bound of outgoing y[1] is: \", JuMP.lower_bound(y[1].out))\n           # A JuMP.Containers.DenseAxisArray of state variables.\n           @variable(subproblem,\n               z[i = 3:4, j = [:A, :B]] >= i, SDDP.State, initial_value = i)\n           println(\"Lower bound of outgoing z[3, :B] is: \", JuMP.lower_bound(z[3, :B].out))\n       end;\nLower bound of outgoing x is: 0.0\nLower bound of outgoing y[1] is: 1.0\nLower bound of outgoing z[3, :B] is: 3.0","category":"page"},{"location":"examples/simple_hydro_thermal/","page":"Hydro-thermal scheduling","title":"Hydro-thermal scheduling","text":"EditURL = \"https://github.com/odow/SDDP.jl/blob/master/docs/src/examples/simple_hydro_thermal.jl\"","category":"page"},{"location":"examples/simple_hydro_thermal/#Hydro-thermal-scheduling","page":"Hydro-thermal scheduling","title":"Hydro-thermal scheduling","text":"","category":"section"},{"location":"examples/simple_hydro_thermal/#Problem-Description","page":"Hydro-thermal scheduling","title":"Problem Description","text":"","category":"section"},{"location":"examples/simple_hydro_thermal/","page":"Hydro-thermal scheduling","title":"Hydro-thermal scheduling","text":"In a hydro-thermal problem, the agent controls a hydro-electric generator and reservoir. Each time period, they need to choose a generation quantity from thermal g_t, and hydro g_h, in order to meed demand w_d, which is a stagewise-independent random variable. The state variable, x, is the quantity of water in the reservoir at the start of each time period, and it has a minimum level of 5 units and a maximum level of 15 units. We assume that there are 10 units of water in the reservoir at the start of time, so that x_0 = 10. The state-variable is connected through time by the water balance constraint: x.out = x.in - g_t - s + w_i, where x.out is the quantity of water at the end of the time period, x.in is the quantity of water at the start of the time period, s is the quantity of water spilled from the reservoir, and w_i is a stagewise-independent random variable that represents the inflow into the reservoir during the time period.","category":"page"},{"location":"examples/simple_hydro_thermal/","page":"Hydro-thermal scheduling","title":"Hydro-thermal scheduling","text":"We assume that there are three stages, t=1, 2, 3, representing summer-fall, winter, and spring, and that we are solving this problem in an infinite-horizon setting with a discount factor of 0.95.","category":"page"},{"location":"examples/simple_hydro_thermal/","page":"Hydro-thermal scheduling","title":"Hydro-thermal scheduling","text":"In each stage, the agent incurs the cost of spillage, plus the cost of thermal generation. We assume that the cost of thermal generation is dependent on the stage t = 1, 2, 3, and that in each stage, w is drawn from the set (w_i, w_d) = {(0, 7.5), (3, 5), (10, 2.5)} with equal probability.","category":"page"},{"location":"examples/simple_hydro_thermal/#Importing-packages","page":"Hydro-thermal scheduling","title":"Importing packages","text":"","category":"section"},{"location":"examples/simple_hydro_thermal/","page":"Hydro-thermal scheduling","title":"Hydro-thermal scheduling","text":"For this example, in addition to SDDP, we need GLPK as a solver and Statisitics to compute the mean of our simulations.","category":"page"},{"location":"examples/simple_hydro_thermal/","page":"Hydro-thermal scheduling","title":"Hydro-thermal scheduling","text":"using GLPK\nusing SDDP\nusing Statistics","category":"page"},{"location":"examples/simple_hydro_thermal/#Constructing-the-policy-graph","page":"Hydro-thermal scheduling","title":"Constructing the policy graph","text":"","category":"section"},{"location":"examples/simple_hydro_thermal/","page":"Hydro-thermal scheduling","title":"Hydro-thermal scheduling","text":"There are three stages in our problem, so we construct a linear policy graph with three stages using SDDP.LinearGraph:","category":"page"},{"location":"examples/simple_hydro_thermal/","page":"Hydro-thermal scheduling","title":"Hydro-thermal scheduling","text":"graph = SDDP.LinearGraph(3)","category":"page"},{"location":"examples/simple_hydro_thermal/","page":"Hydro-thermal scheduling","title":"Hydro-thermal scheduling","text":"Then, because we want to solve an infinite-horizon problem, we add an additional edge between node 3 and node 1 with probability 0.95:","category":"page"},{"location":"examples/simple_hydro_thermal/","page":"Hydro-thermal scheduling","title":"Hydro-thermal scheduling","text":"SDDP.add_edge(graph, 3 => 1, 0.95)","category":"page"},{"location":"examples/simple_hydro_thermal/#Constructing-the-model","page":"Hydro-thermal scheduling","title":"Constructing the model","text":"","category":"section"},{"location":"examples/simple_hydro_thermal/","page":"Hydro-thermal scheduling","title":"Hydro-thermal scheduling","text":"Much of the macro code (i.e., lines starting with @) in the first part of the following should be familiar to users of JuMP.","category":"page"},{"location":"examples/simple_hydro_thermal/","page":"Hydro-thermal scheduling","title":"Hydro-thermal scheduling","text":"Inside the do-end block, sp is a standard JuMP model, and t is an index for the state variable that will be called with t = 1, 2, 3.","category":"page"},{"location":"examples/simple_hydro_thermal/","page":"Hydro-thermal scheduling","title":"Hydro-thermal scheduling","text":"The state variable x, constructed by passing the SDDP.State tag to @variable is actually a Julia struct with two fields: x.in and x.out corresponding to the incoming and outgoing state variables respectively. Both x.in and x.out are standard JuMP variables. The initial_value keyword provides the value of the state variable in the root node (i.e., x_0).","category":"page"},{"location":"examples/simple_hydro_thermal/","page":"Hydro-thermal scheduling","title":"Hydro-thermal scheduling","text":"Compared to a JuMP model, one key difference is that we use @stageobjective instead of @objective. The SDDP.parameterize function takes a list of supports for w and parameterizes the JuMP model sp by setting the right-hand sides of the appropriate constraints (note how the constraints initially have a right-hand side of 0). By default, it is assumed that the realizations have uniform probability, but a probability mass vector can also be provided.","category":"page"},{"location":"examples/simple_hydro_thermal/","page":"Hydro-thermal scheduling","title":"Hydro-thermal scheduling","text":"model = SDDP.PolicyGraph(\n    graph, sense = :Min, lower_bound = 0.0, optimizer = GLPK.Optimizer\n) do sp, t\n    @variable(sp, 5 <= x <= 15, SDDP.State, initial_value = 10)\n    @variable(sp, g_t >= 0)\n    @variable(sp, g_h >= 0)\n    @variable(sp, s >= 0)\n    @constraint(sp, balance, x.out - x.in + g_h + s == 0)\n    @constraint(sp, demand, g_h + g_t == 0)\n    @stageobjective(sp, s + t * g_t)\n    SDDP.parameterize(sp, [[0, 7.5], [3, 5], [10, 2.5]]) do w\n        set_normalized_rhs(balance, w[1])\n        set_normalized_rhs(demand, w[2])\n    end\nend","category":"page"},{"location":"examples/simple_hydro_thermal/#Training-the-policy","page":"Hydro-thermal scheduling","title":"Training the policy","text":"","category":"section"},{"location":"examples/simple_hydro_thermal/","page":"Hydro-thermal scheduling","title":"Hydro-thermal scheduling","text":"Once a model has been constructed, the next step is to train the policy. This can be achieved using SDDP.train. There are many options that can be passed, but iteration_limit terminates the training after the prescribed number of SDDP iterations.","category":"page"},{"location":"examples/simple_hydro_thermal/","page":"Hydro-thermal scheduling","title":"Hydro-thermal scheduling","text":"SDDP.train(model, iteration_limit = 100)","category":"page"},{"location":"examples/simple_hydro_thermal/#Simulating-the-policy","page":"Hydro-thermal scheduling","title":"Simulating the policy","text":"","category":"section"},{"location":"examples/simple_hydro_thermal/","page":"Hydro-thermal scheduling","title":"Hydro-thermal scheduling","text":"After training, we can simulate the policy using SDDP.simulate.","category":"page"},{"location":"examples/simple_hydro_thermal/","page":"Hydro-thermal scheduling","title":"Hydro-thermal scheduling","text":"sims = SDDP.simulate(model, 100, [:g_t])\nmu = round(mean([s[1][:g_t] for s in sims]), digits = 2)\nprintln(\"On average, $(mu) units of thermal are used in the first stage.\")","category":"page"},{"location":"examples/simple_hydro_thermal/#Extracting-the-water-values","page":"Hydro-thermal scheduling","title":"Extracting the water values","text":"","category":"section"},{"location":"examples/simple_hydro_thermal/","page":"Hydro-thermal scheduling","title":"Hydro-thermal scheduling","text":"Finally, we can use SDDP.ValueFunction and SDDP.evaluate to obtain and evaluate the value function at different points in the state-space. Note that since we are minimizing, the price has a negative sign: each additional unit of water leads to a decrease in the the expected long-run cost.","category":"page"},{"location":"examples/simple_hydro_thermal/","page":"Hydro-thermal scheduling","title":"Hydro-thermal scheduling","text":"V = SDDP.ValueFunction(model[1])\ncost, price = SDDP.evaluate(V, x = 10)","category":"page"},{"location":"examples/simple_hydro_thermal/","page":"Hydro-thermal scheduling","title":"Hydro-thermal scheduling","text":"","category":"page"},{"location":"examples/simple_hydro_thermal/","page":"Hydro-thermal scheduling","title":"Hydro-thermal scheduling","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorial/13_integrality/","page":"Advanced III: integrality","title":"Advanced III: integrality","text":"EditURL = \"https://github.com/odow/SDDP.jl/blob/master/docs/src/tutorial/13_integrality.jl\"","category":"page"},{"location":"tutorial/13_integrality/#Advanced-III:-integrality","page":"Advanced III: integrality","title":"Advanced III: integrality","text":"","category":"section"},{"location":"tutorial/13_integrality/","page":"Advanced III: integrality","title":"Advanced III: integrality","text":"The fundamental reason why SDDP works is convexity. In the classical algorithm, this ruled out the use of integer variables. However, various extensions to the algorithm have been proposed, and these can be run by SDDP.jl using the integrality_handler keyword argument to SDDP.PolicyGraph.","category":"page"},{"location":"tutorial/13_integrality/#Continuous-relaxation","page":"Advanced III: integrality","title":"Continuous relaxation","text":"","category":"section"},{"location":"tutorial/13_integrality/","page":"Advanced III: integrality","title":"Advanced III: integrality","text":"If your model includes binary or integer variables (e.g., air_conditioning.jl), passing integrality_handler = SDDP.ContinuousRelaxation() will make SDDP.jl contruct a (sub-optimal) policy using the continuous relaxation of the problem. But, when you simulate this policy, SDDP.jl will solve the original mixed-integer problem.","category":"page"},{"location":"tutorial/13_integrality/#SDDiP","page":"Advanced III: integrality","title":"SDDiP","text":"","category":"section"},{"location":"tutorial/13_integrality/","page":"Advanced III: integrality","title":"Advanced III: integrality","text":"If you pass integrality_handler = SDDP.SDDiP(), SDDP.jl will use the stochastic dual dynamic integer programming method of Zou, Ahmed, and Sun. See SDDP.SDDiP for more.","category":"page"},{"location":"tutorial/13_integrality/","page":"Advanced III: integrality","title":"Advanced III: integrality","text":"","category":"page"},{"location":"tutorial/13_integrality/","page":"Advanced III: integrality","title":"Advanced III: integrality","text":"This page was generated using Literate.jl.","category":"page"},{"location":"guides/add_multidimensional_noise_Terms/#Add-multi-dimensional-noise-terms","page":"Add multi-dimensional noise terms","title":"Add multi-dimensional noise terms","text":"","category":"section"},{"location":"guides/add_multidimensional_noise_Terms/","page":"Add multi-dimensional noise terms","title":"Add multi-dimensional noise terms","text":"DocTestSetup = quote\n    using SDDP, GLPK\nend","category":"page"},{"location":"guides/add_multidimensional_noise_Terms/","page":"Add multi-dimensional noise terms","title":"Add multi-dimensional noise terms","text":"Multi-dimensional stagewise-independent random variables can be created by forming the Cartesian product of the random variables.","category":"page"},{"location":"guides/add_multidimensional_noise_Terms/","page":"Add multi-dimensional noise terms","title":"Add multi-dimensional noise terms","text":"julia> model = SDDP.LinearPolicyGraph(\n               stages=3, lower_bound = 0, optimizer = GLPK.Optimizer\n               ) do subproblem, t\n           @variable(subproblem, x, SDDP.State, initial_value = 0.0)\n           support = [(value = v, coefficient = c) for v in [1, 2] for c in [3, 4, 5]]\n           probability = [pv * pc for pv in [0.5, 0.5] for pc in [0.3, 0.5, 0.2]]\n           SDDP.parameterize(subproblem, support, probability) do ω\n               JuMP.fix(x.out, ω.value)\n               @stageobjective(subproblem, ω.coefficient * x.out)\n               println(\"ω is: \", ω)\n           end\n       end;\n\njulia> SDDP.simulate(model, 1);\nω is: (value = 1, coefficient = 4)\nω is: (value = 1, coefficient = 3)\nω is: (value = 2, coefficient = 4)","category":"page"},{"location":"guides/improve_computational_performance/#Improve-computational-performance","page":"Improve computational performance","title":"Improve computational performance","text":"","category":"section"},{"location":"guides/improve_computational_performance/","page":"Improve computational performance","title":"Improve computational performance","text":"SDDP is a computationally intensive algorithm. Here are some suggestions for how the computational performance can be improved.","category":"page"},{"location":"guides/improve_computational_performance/#Numerical-stability-(again)","page":"Improve computational performance","title":"Numerical stability (again)","text":"","category":"section"},{"location":"guides/improve_computational_performance/","page":"Improve computational performance","title":"Improve computational performance","text":"We've already discussed this in the Numerical stability section of Basic VI: words of warning. But, it's so important that we're going to say it again: improving the problem scaling is one of the best ways to improve the numerical performance of your models.","category":"page"},{"location":"guides/improve_computational_performance/#Solver-selection","page":"Improve computational performance","title":"Solver selection","text":"","category":"section"},{"location":"guides/improve_computational_performance/","page":"Improve computational performance","title":"Improve computational performance","text":"The majority of the solution time is spent inside the low-level solvers. Choosing which solver (and the associated settings) correctly can lead to big speed-ups.","category":"page"},{"location":"guides/improve_computational_performance/","page":"Improve computational performance","title":"Improve computational performance","text":"Choose a commercial solver.\nOptions include CPLEX, Gurobi, and Xpress. Using free solvers such as CLP and GLPK isn't a viable approach for large problems.\nTry different solvers.","category":"page"},{"location":"guides/improve_computational_performance/","page":"Improve computational performance","title":"Improve computational performance","text":"Even commercial solvers can have wildly different solution times. We've seen   models on which CPLEX was 50% fast than Gurobi, and vice versa.","category":"page"},{"location":"guides/improve_computational_performance/","page":"Improve computational performance","title":"Improve computational performance","text":"Experiment with different solver options.\nUsing the default settings is usually a good option. However, sometimes it can pay to change these. In particular, forcing solvers to use the dual simplex algorithm (e.g., Method=1 in Gurobi ) is usually a performance win.","category":"page"},{"location":"guides/improve_computational_performance/#Single-cut-vs.-multi-cut","page":"Improve computational performance","title":"Single-cut vs. multi-cut","text":"","category":"section"},{"location":"guides/improve_computational_performance/","page":"Improve computational performance","title":"Improve computational performance","text":"There are two competing ways that cuts can be created in SDDP: single-cut and multi-cut. By default, SDDP.jl uses the single-cut version of SDDP.","category":"page"},{"location":"guides/improve_computational_performance/","page":"Improve computational performance","title":"Improve computational performance","text":"The performance of each method is problem-dependent. We recommend that you try both in order to see which one performs better. In general, the single-cut method works better when the number of realizations of the stagewise-independent random variable is large, whereas the multi-cut method works better on small problems. However, the multi-cut method can cause numerical stability problems, particularly if used in conjunction with objective or belief state variables.","category":"page"},{"location":"guides/improve_computational_performance/","page":"Improve computational performance","title":"Improve computational performance","text":"You can switch between the methods by passing the relevant flag to cut_type in SDDP.train.","category":"page"},{"location":"guides/improve_computational_performance/","page":"Improve computational performance","title":"Improve computational performance","text":"SDDP.train(model; cut_type = SDDP.SINGLE_CUT)\nSDDP.train(model; cut_type = SDDP.MULTI_CUT)","category":"page"},{"location":"guides/improve_computational_performance/#Parallelism","page":"Improve computational performance","title":"Parallelism","text":"","category":"section"},{"location":"guides/improve_computational_performance/","page":"Improve computational performance","title":"Improve computational performance","text":"SDDP.jl can take advantage of the parallel nature of modern computers to solve problems across multiple cores.","category":"page"},{"location":"guides/improve_computational_performance/","page":"Improve computational performance","title":"Improve computational performance","text":"info: Info\nWe highly recommend that you read the Julia manual's section on parallel computing.","category":"page"},{"location":"guides/improve_computational_performance/","page":"Improve computational performance","title":"Improve computational performance","text":"You can start Julia from a command line with N processors using the -p flag:","category":"page"},{"location":"guides/improve_computational_performance/","page":"Improve computational performance","title":"Improve computational performance","text":"julia -p N","category":"page"},{"location":"guides/improve_computational_performance/","page":"Improve computational performance","title":"Improve computational performance","text":"Alternatively, you can use the Distributed.jl package:","category":"page"},{"location":"guides/improve_computational_performance/","page":"Improve computational performance","title":"Improve computational performance","text":"using Distributed\nDistributed.addprocs(N)","category":"page"},{"location":"guides/improve_computational_performance/","page":"Improve computational performance","title":"Improve computational performance","text":"warning: Warning\nWorkers DON'T inherit their parent's Pkg environment. Therefore, if you started Julia with --project=/path/to/environment (or if you activated an environment from the REPL), you will need to put the following at the top of your script:using Distributed\n@everywhere begin\n    import Pkg\n    Pkg.activate(\"/path/to/environment\")\nend","category":"page"},{"location":"guides/improve_computational_performance/","page":"Improve computational performance","title":"Improve computational performance","text":"Currently SDDP.jl supports to parallel schemes, SDDP.Serial and SDDP.Asynchronous. Instances of these parallel schemes should be passed to the parallel_scheme argument of SDDP.train and SDDP.simulate.","category":"page"},{"location":"guides/improve_computational_performance/","page":"Improve computational performance","title":"Improve computational performance","text":"using SDDP, GLPK\nmodel = SDDP.LinearPolicyGraph(\n  stages = 2, lower_bound = 0, optimizer = GLPK.Optimizer\n) do sp, t\n     @variable(sp, x >= 0, SDDP.State, initial_value = 1)\n     @stageobjective(sp, x.out)\nend\nSDDP.train(model; iteration_limit = 10, parallel_scheme = SDDP.Asynchronous())\nSDDP.simulate(model, 10; parallel_scheme = SDDP.Asynchronous())","category":"page"},{"location":"guides/improve_computational_performance/","page":"Improve computational performance","title":"Improve computational performance","text":"There is a large overhead for using the asynchronous solver. Even if you choose asynchronous mode, SDDP.jl will start in serial mode while the initialization takes place. Therefore, in the log you will see that the initial iterations take place on the master thread (Proc. ID = 1), and it is only after while that the solve switches to full parallelism.","category":"page"},{"location":"guides/improve_computational_performance/","page":"Improve computational performance","title":"Improve computational performance","text":"info: Info\nBecause of the large data communication requirements (all cuts have to be shared with all other cores), the solution time will not scale linearly with the number of cores.","category":"page"},{"location":"guides/improve_computational_performance/","page":"Improve computational performance","title":"Improve computational performance","text":"info: Info\nGiven the same number of iterations, the policy obtained from asynchronous mode will be worse than the policy obtained from serial mode. However, the asynchronous solver can take significantly less time to compute the same number of iterations.","category":"page"},{"location":"guides/improve_computational_performance/#Data-movement","page":"Improve computational performance","title":"Data movement","text":"","category":"section"},{"location":"guides/improve_computational_performance/","page":"Improve computational performance","title":"Improve computational performance","text":"By defualt, data defined on the master process is not made available to the workers. Therefore, a model like the following:","category":"page"},{"location":"guides/improve_computational_performance/","page":"Improve computational performance","title":"Improve computational performance","text":"data = 1\nmodel = SDDP.LinearPolicyGraph(stages = 2, lower_bound = 0) do sp, t\n     @variable(sp, x >= 0, SDDP.State, initial_value = data)\n     @stageobjective(sp, x.out)\nend","category":"page"},{"location":"guides/improve_computational_performance/","page":"Improve computational performance","title":"Improve computational performance","text":"will result in an UndefVarError error like UndefVarError: data not defined.","category":"page"},{"location":"guides/improve_computational_performance/","page":"Improve computational performance","title":"Improve computational performance","text":"There are three solutions for this problem.","category":"page"},{"location":"guides/improve_computational_performance/#Option-1:-declare-data-inside-the-build-function","page":"Improve computational performance","title":"Option 1: declare data inside the build function","text":"","category":"section"},{"location":"guides/improve_computational_performance/","page":"Improve computational performance","title":"Improve computational performance","text":"model = SDDP.LinearPolicyGraph(stages = 2) do sp, t\n    data = 1\n    @variable(sp, x >= 0, SDDP.State, initial_value = 1)\n    @stageobjective(sp, x)\nend","category":"page"},{"location":"guides/improve_computational_performance/#Option-2:-use-@everywhere","page":"Improve computational performance","title":"Option 2: use @everywhere","text":"","category":"section"},{"location":"guides/improve_computational_performance/","page":"Improve computational performance","title":"Improve computational performance","text":"@everywhere begin\n    data = 1\nend\nmodel = SDDP.LinearPolicyGraph(stages = 2) do sp, t\n    @variable(sp, x >= 0, SDDP.State, initial_value = 1)\n    @stageobjective(sp, x)\nend","category":"page"},{"location":"guides/improve_computational_performance/#Option-3:-build-the-model-in-a-function","page":"Improve computational performance","title":"Option 3: build the model in a function","text":"","category":"section"},{"location":"guides/improve_computational_performance/","page":"Improve computational performance","title":"Improve computational performance","text":"function build_model()\n    data = 1\n    return SDDP.LinearPolicyGraph(stages = 2) do sp, t\n        @variable(sp, x >= 0, SDDP.State, initial_value = 1)\n        @stageobjective(sp, x)\n    end\nend\n\nmodel = build_model()","category":"page"},{"location":"guides/improve_computational_performance/#Initialization-hooks","page":"Improve computational performance","title":"Initialization hooks","text":"","category":"section"},{"location":"guides/improve_computational_performance/","page":"Improve computational performance","title":"Improve computational performance","text":"SDDP.Asynchronous accepts a pre-processing hook that is run on each worker process before the model is solved. The most useful situation is for solvers than need an initialization step. A good example is Gurobi, which can share an environment amongst all models on a worker. Notably, this environment cannot be shared amongst workers, so defining one environment at the top of a script will fail!","category":"page"},{"location":"guides/improve_computational_performance/","page":"Improve computational performance","title":"Improve computational performance","text":"To initialize a new environment on each worker, use the following:","category":"page"},{"location":"guides/improve_computational_performance/","page":"Improve computational performance","title":"Improve computational performance","text":"SDDP.train(\n    model,\n    parallel_scheme = SDDP.Asynchronous() do m\n        env = Gurobi.Env()\n        optimizer = with_optimizer(Gurobi.Optimizer, env, OutputFlag = 0)\n        for node in values(m.nodes)\n            set_optimizer(node.subproblem, optimizer)\n        end\n    end\n)","category":"page"},{"location":"guides/add_a_risk_measure/#Add-a-risk-measure","page":"Add a risk measure","title":"Add a risk measure","text":"","category":"section"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"DocTestSetup = quote\n    using SDDP, GLPK\nend","category":"page"},{"location":"guides/add_a_risk_measure/#Training-a-risk-averse-model","page":"Add a risk measure","title":"Training a risk-averse model","text":"","category":"section"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"SDDP.jl supports a variety of risk measures. Two common ones are SDDP.Expectation and SDDP.WorstCase. Let's see how to train a policy using them. There are three possible ways.","category":"page"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"If the same risk measure is used at every node in the policy graph, we can just pass an instance of one of the risk measures to the risk_measure keyword argument of the SDDP.train function.","category":"page"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"SDDP.train(\n    model,\n    risk_measure = SDDP.WorstCase(),\n    iteration_limit = 10\n)","category":"page"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"However, if you want different risk measures at different nodes, there are two options. First, you can pass risk_measure a dictionary of risk measures, with one entry for each node. The keys of the dictionary are the indices of the nodes.","category":"page"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"SDDP.train(\n    model,\n    risk_measure = Dict(\n        1 => SDDP.Expectation(),\n        2 => SDDP.WorstCase()\n    ),\n    iteration_limit = 10\n)","category":"page"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"An alternative method is to pass risk_measure a function that takes one argument, the index of a node, and returns an instance of a risk measure:","category":"page"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"SDDP.train(\n    model,\n    risk_measure = (node_index) -> begin\n        if node_index == 1\n            return SDDP.Expectation()\n        else\n            return SDDP.WorstCase()\n        end\n    end,\n    iteration_limit = 10\n)","category":"page"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"note: Note\nIf you simulate the policy, the simulated value is the risk-neutral value of the policy.","category":"page"},{"location":"guides/add_a_risk_measure/#Risk-measures","page":"Add a risk measure","title":"Risk measures","text":"","category":"section"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"To illustrate the risk-measures included in SDDP.jl, we consider a discrete random variable with four outcomes.","category":"page"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"The random variable is supported on the values 1, 2, 3, and 4:","category":"page"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"julia> noise_supports = [1, 2, 3, 4]\n4-element Array{Int64,1}:\n 1\n 2\n 3\n 4","category":"page"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"The associated probability of each outcome is as follows:","category":"page"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"julia> nominal_probability = [0.1, 0.2, 0.3, 0.4]\n4-element Array{Float64,1}:\n 0.1\n 0.2\n 0.3\n 0.4","category":"page"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"With each outcome ω, the agent observes a cost Z(ω):","category":"page"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"julia> cost_realizations = [5.0, 4.0, 6.0, 2.0]\n4-element Array{Float64,1}:\n 5.0\n 4.0\n 6.0\n 2.0","category":"page"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"We assume that we are minimizing:","category":"page"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"julia> is_minimization = true\ntrue","category":"page"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"Finally, we create a vector that will be used to store the risk-adjusted probabilities:","category":"page"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"julia> risk_adjusted_probability = zeros(4)\n4-element Array{Float64,1}:\n 0.0\n 0.0\n 0.0\n 0.0","category":"page"},{"location":"guides/add_a_risk_measure/#Expectation","page":"Add a risk measure","title":"Expectation","text":"","category":"section"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"SDDP.Expectation","category":"page"},{"location":"guides/add_a_risk_measure/#SDDP.Expectation","page":"Add a risk measure","title":"SDDP.Expectation","text":"Expectation()\n\nThe Expectation risk measure. Identical to taking the expectation with respect to the nominal distribution.\n\n\n\n\n\n","category":"type"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"SDDP.adjust_probability(\n    SDDP.Expectation(),\n    risk_adjusted_probability,\n    nominal_probability,\n    noise_supports,\n    cost_realizations,\n    is_minimization\n)\n\nrisk_adjusted_probability\n\n# output\n\n4-element Array{Float64,1}:\n 0.1\n 0.2\n 0.3\n 0.4","category":"page"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"SDDP.Expectation is the default risk measure in SDDP.jl.","category":"page"},{"location":"guides/add_a_risk_measure/#Worst-case","page":"Add a risk measure","title":"Worst-case","text":"","category":"section"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"SDDP.WorstCase","category":"page"},{"location":"guides/add_a_risk_measure/#SDDP.WorstCase","page":"Add a risk measure","title":"SDDP.WorstCase","text":"WorstCase()\n\nThe worst-case risk measure. Places all of the probability weight on the worst outcome.\n\n\n\n\n\n","category":"type"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"SDDP.adjust_probability(\n    SDDP.WorstCase(),\n    risk_adjusted_probability,\n    nominal_probability,\n    noise_supports,\n    cost_realizations,\n    is_minimization\n)\n\nrisk_adjusted_probability\n\n# output\n\n4-element Array{Float64,1}:\n 0.0\n 0.0\n 1.0\n 0.0","category":"page"},{"location":"guides/add_a_risk_measure/#Average-value-at-risk-(AV@R)","page":"Add a risk measure","title":"Average value at risk (AV@R)","text":"","category":"section"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"SDDP.AVaR","category":"page"},{"location":"guides/add_a_risk_measure/#SDDP.AVaR","page":"Add a risk measure","title":"SDDP.AVaR","text":"AVaR(β)\n\nThe average value at risk (AV@R) risk measure.\n\nComputes the expectation of the β fraction of worst outcomes. β must be in [0, 1]. When β=1, this is equivalent to the Expectation risk measure. When β=0, this is equivalent  to the WorstCase risk measure.\n\nAV@R is also known as the conditional value at risk (CV@R) or expected shortfall.\n\n\n\n\n\n","category":"type"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"SDDP.adjust_probability(\n    SDDP.AVaR(0.5),\n    risk_adjusted_probability,\n    nominal_probability,\n    noise_supports,\n    cost_realizations,\n    is_minimization\n)\n\nround.(risk_adjusted_probability, digits = 1)\n\n# output\n\n4-element Array{Float64,1}:\n 0.2\n 0.2\n 0.6\n 0.0","category":"page"},{"location":"guides/add_a_risk_measure/#Convex-combination-of-risk-measures","page":"Add a risk measure","title":"Convex combination of risk measures","text":"","category":"section"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"Using the axioms of coherent risk measures, it is easy to show that any convex combination of coherent risk measures is also a coherent risk measure. Convex combinations of risk measures can be created directly:","category":"page"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"julia> cvx_comb_measure = 0.5 * SDDP.Expectation() + 0.5 * SDDP.WorstCase()\nA convex combination of 0.5 * SDDP.Expectation() + 0.5 * SDDP.WorstCase()","category":"page"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"SDDP.adjust_probability(\n    cvx_comb_measure,\n    risk_adjusted_probability,\n    nominal_probability,\n    noise_supports,\n    cost_realizations,\n    is_minimization\n)\n\nrisk_adjusted_probability\n\n# output\n\n4-element Array{Float64,1}:\n 0.05\n 0.1\n 0.65\n 0.2","category":"page"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"As a special case, the SDDP.EAVaR risk-measure is a convex combination of SDDP.Expectation and SDDP.AVaR:","category":"page"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"julia> risk_measure = SDDP.EAVaR(beta=0.25, lambda=0.4)\nA convex combination of 0.4 * SDDP.Expectation() + 0.6 * SDDP.AVaR(0.25)","category":"page"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"SDDP.EAVaR","category":"page"},{"location":"guides/add_a_risk_measure/#SDDP.EAVaR","page":"Add a risk measure","title":"SDDP.EAVaR","text":"EAVaR(;lambda=1.0, beta=1.0)\n\nA risk measure that is a convex combination of Expectation and Average Value @ Risk (also called Conditional Value @ Risk).\n\n    λ * E[x] + (1 - λ) * AV@R(1-β)[x]\n\nKeyword Arguments\n\nlambda: Convex weight on the expectation ((1-lambda) weight is put on the AV@R component. Inreasing values of lambda are less risk averse (more weight on expectation).\nbeta: The quantile at which to calculate the Average Value @ Risk. Increasing values of beta are less risk averse. If beta=0, then the AV@R component is the worst case risk measure.\n\n\n\n\n\n","category":"function"},{"location":"guides/add_a_risk_measure/#Distributionally-robust","page":"Add a risk measure","title":"Distributionally robust","text":"","category":"section"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"SDDP.jl supports two types of distrbutionally robust risk measures: the modified Χ² method of Philpott et al. (2018), and a method based on the Wasserstein distance metric.","category":"page"},{"location":"guides/add_a_risk_measure/#Modified-Chi-squard","page":"Add a risk measure","title":"Modified Chi-squard","text":"","category":"section"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"SDDP.ModifiedChiSquared","category":"page"},{"location":"guides/add_a_risk_measure/#SDDP.ModifiedChiSquared","page":"Add a risk measure","title":"SDDP.ModifiedChiSquared","text":"ModifiedChiSquared(radius::Float64; minimum_std=1e-5)\n\nThe distributionally robust SDDP risk measure of Philpott, A., de Matos, V., Kapelevich, L. Distributionally robust SDDP. Computational Management Science (2018) 165:431-454.\n\nIf the uncorrected standard deviation of the objecive realizations is less than minimum_std, then the risk-measure will default to Expectation().\n\n\n\n\n\n","category":"type"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"SDDP.adjust_probability(\n    SDDP.ModifiedChiSquared(0.5),\n    risk_adjusted_probability,\n    [0.25, 0.25, 0.25, 0.25],\n    noise_supports,\n    cost_realizations,\n    is_minimization\n)\n\nround.(risk_adjusted_probability, digits = 4)\n\n# output\n\n4-element Array{Float64,1}:\n 0.3333\n 0.0447\n 0.622\n 0.0","category":"page"},{"location":"guides/add_a_risk_measure/#Wasserstein","page":"Add a risk measure","title":"Wasserstein","text":"","category":"section"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"SDDP.Wasserstein","category":"page"},{"location":"guides/add_a_risk_measure/#SDDP.Wasserstein","page":"Add a risk measure","title":"SDDP.Wasserstein","text":"Wasserstein(norm::Function, solver_factory; alpha::Float64)\n\nA distributionally-robust risk measure based on the Wasserstein distance.\n\nAs alpha increases, the measure becomes more risk-averse. When alpha=0, the measure is equivalent to the expectation operator. As alpha increases, the measure approaches the Worst-case risk measure.\n\n\n\n\n\n","category":"type"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"risk_measure = SDDP.Wasserstein(\n        GLPK.Optimizer; alpha=0.5) do x, y\n   return abs(x - y)\nend\n\nSDDP.adjust_probability(\n    risk_measure,\n    risk_adjusted_probability,\n    nominal_probability,\n    noise_supports,\n    cost_realizations,\n    is_minimization\n)\n\nround.(risk_adjusted_probability, digits = 1)\n\n# output\n\n4-element Array{Float64,1}:\n 0.1\n 0.1\n 0.8\n 0.0","category":"page"},{"location":"guides/add_a_risk_measure/#Entropic","page":"Add a risk measure","title":"Entropic","text":"","category":"section"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"SDDP.Entropic","category":"page"},{"location":"guides/add_a_risk_measure/#SDDP.Entropic","page":"Add a risk measure","title":"SDDP.Entropic","text":"Entropic(γ::Float64)\n\nThe entropic risk measure as described by Dowson, Morton, and Pagnoncelli (2020). Multistage stochastic programs with the entropic risk measure. http://www.optimization-online.org/DB_HTML/2020/08/7984.html\n\n\n\n\n\n","category":"type"},{"location":"guides/add_a_risk_measure/","page":"Add a risk measure","title":"Add a risk measure","text":"risk_measure = SDDP.Entropic(0.1)\n\nSDDP.adjust_probability(\n    risk_measure,\n    risk_adjusted_probability,\n    nominal_probability,\n    noise_supports,\n    cost_realizations,\n    is_minimization\n)\n\nround.(risk_adjusted_probability, digits = 4)\n\n# output\n\n4-element Array{Float64,1}:\n 0.11\n 0.1991\n 0.3648\n 0.326","category":"page"},{"location":"tutorial/04_markov_uncertainty/","page":"Basic IV: Markov uncertainty","title":"Basic IV: Markov uncertainty","text":"EditURL = \"https://github.com/odow/SDDP.jl/blob/master/docs/src/tutorial/04_markov_uncertainty.jl\"","category":"page"},{"location":"tutorial/04_markov_uncertainty/#Basic-IV:-Markov-uncertainty","page":"Basic IV: Markov uncertainty","title":"Basic IV: Markov uncertainty","text":"","category":"section"},{"location":"tutorial/04_markov_uncertainty/","page":"Basic IV: Markov uncertainty","title":"Basic IV: Markov uncertainty","text":"In our three tutorials (Basic I: first steps, Basic II: adding uncertainty, and Basic III: objective uncertainty), we formulated a simple hydrothermal scheduling problem with stagewise-independent noise in the right-hand side of the constraints and in the objective function. Now, in this tutorial, we introduce some stagewise-dependent uncertainty using a Markov chain.","category":"page"},{"location":"tutorial/04_markov_uncertainty/#Formulating-the-problem","page":"Basic IV: Markov uncertainty","title":"Formulating the problem","text":"","category":"section"},{"location":"tutorial/04_markov_uncertainty/","page":"Basic IV: Markov uncertainty","title":"Basic IV: Markov uncertainty","text":"In this tutorial we consider a Markov chain with two climate states: wet and dry. Each Markov state is associated with an integer, in this case the wet climate state  is Markov state 1 and the dry climate state is Markov state 2. In the wet climate state, the probability of the high inflow increases to 50%, and the probability of the low inflow decreases to 1/6. In the dry climate state, the converse happens. There is also persistence in the climate state: the probability of remaining in the current state is 75%, and the probability of transitioning to the other climate state is 25%. We assume that the first stage starts in the wet climate state.","category":"page"},{"location":"tutorial/04_markov_uncertainty/","page":"Basic IV: Markov uncertainty","title":"Basic IV: Markov uncertainty","text":"Here is a picture of the model we're going to implement.","category":"page"},{"location":"tutorial/04_markov_uncertainty/","page":"Basic IV: Markov uncertainty","title":"Basic IV: Markov uncertainty","text":"(Image: Markovian policy graph)","category":"page"},{"location":"tutorial/04_markov_uncertainty/","page":"Basic IV: Markov uncertainty","title":"Basic IV: Markov uncertainty","text":"There are five nodes in our graph. Each node is named by a tuple (t, i), where t is the stage for t=1,2,3, and i is the Markov state for i=1,2. As before, the wavy lines denote the stagewise-independent random variable.","category":"page"},{"location":"tutorial/04_markov_uncertainty/","page":"Basic IV: Markov uncertainty","title":"Basic IV: Markov uncertainty","text":"For each stage, we need to provide a Markov transition matrix. This is an MxN matrix, where the element A[i, j] gives the probability of transitioning from Markov state i in the previous stage to Markov state j in the current stage. The first stage is special because we assume there is a \"zero'th\" stage which has one Markov state (the round node in the graph above). Furthermore, the number of columns in the transition matrix of a stage (i.e. the number of Markov states) must equal the number of rows in the next stage's transition matrix. For our example, the vector of Markov transition matrices is given by:","category":"page"},{"location":"tutorial/04_markov_uncertainty/","page":"Basic IV: Markov uncertainty","title":"Basic IV: Markov uncertainty","text":"T = Array{Float64, 2}[\n    [ 1.0 ]',\n    [ 0.75 0.25 ],\n    [ 0.75 0.25 ; 0.25 0.75 ]\n]","category":"page"},{"location":"tutorial/04_markov_uncertainty/","page":"Basic IV: Markov uncertainty","title":"Basic IV: Markov uncertainty","text":"note: Note\nMake sure to add the ' after the first transition matrix so Julia can distinguish between a vector and a matrix.","category":"page"},{"location":"tutorial/04_markov_uncertainty/#Creating-a-model","page":"Basic IV: Markov uncertainty","title":"Creating a model","text":"","category":"section"},{"location":"tutorial/04_markov_uncertainty/","page":"Basic IV: Markov uncertainty","title":"Basic IV: Markov uncertainty","text":"using SDDP, GLPK\n\nΩ = [\n    (inflow = 0.0, fuel_multiplier = 1.5),\n    (inflow = 50.0, fuel_multiplier = 1.0),\n    (inflow = 100.0, fuel_multiplier = 0.75)\n]\n\nmodel = SDDP.MarkovianPolicyGraph(\n    transition_matrices = Array{Float64, 2}[\n        [ 1.0 ]',\n        [ 0.75 0.25 ],\n        [ 0.75 0.25 ; 0.25 0.75 ]\n    ],\n    sense = :Min,\n    lower_bound = 0.0,\n    optimizer = GLPK.Optimizer\n) do subproblem, node\n    # Unpack the stage and Markov index.\n    t, markov_state = node\n    # Define the state variable.\n    @variable(subproblem, 0 <= volume <= 200, SDDP.State, initial_value = 200)\n    # Define the control variables.\n    @variables(subproblem, begin\n        thermal_generation >= 0\n        hydro_generation   >= 0\n        hydro_spill        >= 0\n        inflow\n    end)\n    # Define the constraints\n    @constraints(subproblem, begin\n        volume.out == volume.in + inflow - hydro_generation - hydro_spill\n        thermal_generation + hydro_generation == 150.0\n    end)\n    # Note how we can use `markov_state` to dispatch an `if` statement.\n    probability = if markov_state == 1  # wet climate state\n        [1/6, 1/3, 1/2]\n    else  # dry climate state\n        [1/2, 1/3, 1/6]\n    end\n\n    fuel_cost = [50.0, 100.0, 150.0]\n    SDDP.parameterize(subproblem, Ω, probability) do ω\n        JuMP.fix(inflow, ω.inflow)\n        @stageobjective(subproblem,\n            ω.fuel_multiplier * fuel_cost[t] * thermal_generation\n        )\n    end\nend","category":"page"},{"location":"tutorial/04_markov_uncertainty/","page":"Basic IV: Markov uncertainty","title":"Basic IV: Markov uncertainty","text":"tip: Tip\nFor more information on SDDP.MarkovianPolicyGraphs, read Create a general policy graph.","category":"page"},{"location":"tutorial/04_markov_uncertainty/#Training-and-simulating-the-policy","page":"Basic IV: Markov uncertainty","title":"Training and simulating the policy","text":"","category":"section"},{"location":"tutorial/04_markov_uncertainty/","page":"Basic IV: Markov uncertainty","title":"Basic IV: Markov uncertainty","text":"As in the previous three tutorials, we train the policy:","category":"page"},{"location":"tutorial/04_markov_uncertainty/","page":"Basic IV: Markov uncertainty","title":"Basic IV: Markov uncertainty","text":"SDDP.train(model; iteration_limit = 10)","category":"page"},{"location":"tutorial/04_markov_uncertainty/","page":"Basic IV: Markov uncertainty","title":"Basic IV: Markov uncertainty","text":"Instead of performing a Monte Carlo simulation like the previous tutorials, we may want to simulate one particular sequence of noise realizations. This historical simulation can also be conducted by passing a SDDP.Historical sampling scheme to the sampling_scheme keyword of the SDDP.simulate function.","category":"page"},{"location":"tutorial/04_markov_uncertainty/","page":"Basic IV: Markov uncertainty","title":"Basic IV: Markov uncertainty","text":"We can confirm that the historical sequence of nodes was visited by querying the :node_index key of the simulation results.","category":"page"},{"location":"tutorial/04_markov_uncertainty/","page":"Basic IV: Markov uncertainty","title":"Basic IV: Markov uncertainty","text":"simulations = SDDP.simulate(\n    model,\n    sampling_scheme = SDDP.Historical([\n        ((1, 1), Ω[1]),\n        ((2, 2), Ω[3]),\n        ((3, 1), Ω[2])\n    ])\n)\n\n[stage[:node_index] for stage in simulations[1]]","category":"page"},{"location":"tutorial/04_markov_uncertainty/","page":"Basic IV: Markov uncertainty","title":"Basic IV: Markov uncertainty","text":"This concludes our fourth tutorial for SDDP.jl. In the next tutorial, Basic V: plotting we discuss the plotting utilities included in SDDP.jl.","category":"page"},{"location":"tutorial/04_markov_uncertainty/","page":"Basic IV: Markov uncertainty","title":"Basic IV: Markov uncertainty","text":"","category":"page"},{"location":"tutorial/04_markov_uncertainty/","page":"Basic IV: Markov uncertainty","title":"Basic IV: Markov uncertainty","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorial/02_adding_uncertainty/","page":"Basic II: adding uncertainty","title":"Basic II: adding uncertainty","text":"EditURL = \"https://github.com/odow/SDDP.jl/blob/master/docs/src/tutorial/02_adding_uncertainty.jl\"","category":"page"},{"location":"tutorial/02_adding_uncertainty/#Basic-II:-adding-uncertainty","page":"Basic II: adding uncertainty","title":"Basic II: adding uncertainty","text":"","category":"section"},{"location":"tutorial/02_adding_uncertainty/","page":"Basic II: adding uncertainty","title":"Basic II: adding uncertainty","text":"In the previous tutorial, Basic I: first steps, we created a deterministic hydro-thermal scheduling model. In this tutorial, we extend the problem by adding uncertainty.","category":"page"},{"location":"tutorial/02_adding_uncertainty/","page":"Basic II: adding uncertainty","title":"Basic II: adding uncertainty","text":"The key development is that we are going to implement a function called SDDP.parameterize, which modifies the subproblem based on a realization of the uncertainty omega.","category":"page"},{"location":"tutorial/02_adding_uncertainty/","page":"Basic II: adding uncertainty","title":"Basic II: adding uncertainty","text":"Notably missing from our previous model were inflows. Inflows are the water that flows into the reservoir through rainfall or rivers. These inflows are uncertain, and are the cause of the main trade-off in hydro-thermal scheduling: the desire to use water now to generate cheap electricity, against the risk that future inflows will be low, leading to blackouts or expensive thermal generation.","category":"page"},{"location":"tutorial/02_adding_uncertainty/","page":"Basic II: adding uncertainty","title":"Basic II: adding uncertainty","text":"For our simple model, we assume that the inflows can be modelled by a discrete distribution with the three outcomes given in the following table:","category":"page"},{"location":"tutorial/02_adding_uncertainty/","page":"Basic II: adding uncertainty","title":"Basic II: adding uncertainty","text":"ω 0 50 100\nP(ω) 1/3 1/3 1/3","category":"page"},{"location":"tutorial/02_adding_uncertainty/","page":"Basic II: adding uncertainty","title":"Basic II: adding uncertainty","text":"The value of the noise (the random variable) is observed by the agent at the start of each stage. This makes the problem a wait-and-see or hazard-decision formulation.","category":"page"},{"location":"tutorial/02_adding_uncertainty/","page":"Basic II: adding uncertainty","title":"Basic II: adding uncertainty","text":"To represent this, we can draw the following picture. The wavy lines denote the uncertainty arriving into the start of each stage (node).","category":"page"},{"location":"tutorial/02_adding_uncertainty/","page":"Basic II: adding uncertainty","title":"Basic II: adding uncertainty","text":"(Image: Linear policy graph)","category":"page"},{"location":"tutorial/02_adding_uncertainty/","page":"Basic II: adding uncertainty","title":"Basic II: adding uncertainty","text":"In addition to adding this uncertainty to the model, we also need to modify the dynamics to include inflow:","category":"page"},{"location":"tutorial/02_adding_uncertainty/","page":"Basic II: adding uncertainty","title":"Basic II: adding uncertainty","text":"volume.out = volume.in + inflow - hydro_generation - hydro_spill","category":"page"},{"location":"tutorial/02_adding_uncertainty/#Creating-a-model","page":"Basic II: adding uncertainty","title":"Creating a model","text":"","category":"section"},{"location":"tutorial/02_adding_uncertainty/","page":"Basic II: adding uncertainty","title":"Basic II: adding uncertainty","text":"To add an uncertain variable to the model, we create a new JuMP variable inflow, and then call the function SDDP.parameterize. The SDDP.parameterize function takes three arguments: the subproblem, a vector of realizations, and a corresponding vector of probabilities.","category":"page"},{"location":"tutorial/02_adding_uncertainty/","page":"Basic II: adding uncertainty","title":"Basic II: adding uncertainty","text":"using SDDP, GLPK\n\nmodel = SDDP.LinearPolicyGraph(\n    stages = 3,\n    sense = :Min,\n    lower_bound = 0.0,\n    optimizer = GLPK.Optimizer\n) do subproblem, t\n    # Define the state variable.\n    @variable(subproblem, 0 <= volume <= 200, SDDP.State, initial_value = 200)\n    # Define the control variables.\n    @variables(subproblem, begin\n        thermal_generation >= 0\n        hydro_generation   >= 0\n        hydro_spill        >= 0\n        inflow\n    end)\n    # Define the constraints\n    @constraints(subproblem, begin\n        volume.out == volume.in + inflow - hydro_generation - hydro_spill\n        demand_constraint, thermal_generation + hydro_generation == 150.0\n    end)\n    # Define the objective for each stage `t`. Note that we can use `t` as an\n    # index for t = 1, 2, 3.\n    fuel_cost = [50.0, 100.0, 150.0]\n    @stageobjective(subproblem, fuel_cost[t] * thermal_generation)\n    # Parameterize the subproblem.\n    SDDP.parameterize(subproblem, [0.0, 50.0, 100.0], [1/3, 1/3, 1/3]) do ω\n        JuMP.fix(inflow, ω)\n    end\nend","category":"page"},{"location":"tutorial/02_adding_uncertainty/","page":"Basic II: adding uncertainty","title":"Basic II: adding uncertainty","text":"Note how we use the JuMP function JuMP.fix to set the value of the inflow variable to ω.","category":"page"},{"location":"tutorial/02_adding_uncertainty/","page":"Basic II: adding uncertainty","title":"Basic II: adding uncertainty","text":"note: Note\nSDDP.parameterize can only be called once in each subproblem definition!","category":"page"},{"location":"tutorial/02_adding_uncertainty/#Training-and-simulating-the-policy","page":"Basic II: adding uncertainty","title":"Training and simulating the policy","text":"","category":"section"},{"location":"tutorial/02_adding_uncertainty/","page":"Basic II: adding uncertainty","title":"Basic II: adding uncertainty","text":"As in Basic I: first steps, we train the policy:","category":"page"},{"location":"tutorial/02_adding_uncertainty/","page":"Basic II: adding uncertainty","title":"Basic II: adding uncertainty","text":"SDDP.train(model; iteration_limit = 10)","category":"page"},{"location":"tutorial/02_adding_uncertainty/","page":"Basic II: adding uncertainty","title":"Basic II: adding uncertainty","text":"We can also simulate the policy. Note that this time, the simulation is stochastic. One common approach to quantify the quality of the policy is to perform  a Monte Carlo simulation and then form a confidence interval for the expected cost. This confidence interval is an estimate for the upper bound.","category":"page"},{"location":"tutorial/02_adding_uncertainty/","page":"Basic II: adding uncertainty","title":"Basic II: adding uncertainty","text":"In addition to the confidence interval, we can calculate the lower bound using SDDP.calculate_bound.","category":"page"},{"location":"tutorial/02_adding_uncertainty/","page":"Basic II: adding uncertainty","title":"Basic II: adding uncertainty","text":"using Statistics\n\nsimulations = SDDP.simulate(model, 500)\n\nobjective_values = [\n    sum(stage[:stage_objective] for stage in sim) for sim in simulations\n]\n\nμ = round(mean(objective_values), digits = 2)\n\nci = round(1.96 * std(objective_values) / sqrt(500), digits = 2)\n\nprintln(\"Confidence interval: \", μ, \" ± \", ci)\nprintln(\"Lower bound: \", round(SDDP.calculate_bound(model), digits = 2))","category":"page"},{"location":"tutorial/02_adding_uncertainty/","page":"Basic II: adding uncertainty","title":"Basic II: adding uncertainty","text":"In addition to simulating the primal values of variables, we can also pass SDDP.jl custom recorder functions. Each of these functions takes one argument, the JuMP subproblem, and returns anything you can compute. For example, the dual of the demand constraint (which we named demand_constraint) corresponds to the price we should charge for electricity, since it represents the cost of each additional unit of demand. To calculate this, we can go","category":"page"},{"location":"tutorial/02_adding_uncertainty/","page":"Basic II: adding uncertainty","title":"Basic II: adding uncertainty","text":"simulations = SDDP.simulate(\n    model,\n    1,\n    custom_recorders = Dict{Symbol, Function}(\n        :price => (sp) -> JuMP.dual(sp[:demand_constraint])\n    )\n)\n\nprices = [stage[:price] for stage in simulations[1]]","category":"page"},{"location":"tutorial/02_adding_uncertainty/","page":"Basic II: adding uncertainty","title":"Basic II: adding uncertainty","text":"This concludes our second tutorial for SDDP.jl. In the next tutorial, Basic III: objective uncertainty, we extend the uncertainty to the fuel cost.","category":"page"},{"location":"tutorial/02_adding_uncertainty/","page":"Basic II: adding uncertainty","title":"Basic II: adding uncertainty","text":"","category":"page"},{"location":"tutorial/02_adding_uncertainty/","page":"Basic II: adding uncertainty","title":"Basic II: adding uncertainty","text":"This page was generated using Literate.jl.","category":"page"},{"location":"apireference/#api_reference_list","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"apireference/#Policy-graphs","page":"API Reference","title":"Policy graphs","text":"","category":"section"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"SDDP.Graph\nSDDP.add_node\nSDDP.add_edge\nSDDP.add_ambiguity_set\nSDDP.LinearGraph\nSDDP.MarkovianGraph\nSDDP.LinearPolicyGraph\nSDDP.MarkovianPolicyGraph\nSDDP.PolicyGraph","category":"page"},{"location":"apireference/#SDDP.Graph","page":"API Reference","title":"SDDP.Graph","text":"Graph(root_node::T) where T\n\nCreate an empty graph struture with the root node root_node.\n\n\n\n\n\n","category":"type"},{"location":"apireference/#SDDP.add_node","page":"API Reference","title":"SDDP.add_node","text":"add_node(graph::Graph{T}, node::T) where T\n\nAdd a node to the graph graph.\n\nExamples\n\nadd_node(graph, :A)\n\n\n\n\n\n","category":"function"},{"location":"apireference/#SDDP.add_edge","page":"API Reference","title":"SDDP.add_edge","text":"add_edge(graph::Graph{T}, edge::Pair{T, T}, probability::Float64) where T\n\nAdd an edge to the graph graph.\n\nExamples\n\nadd_edge(graph, 1 => 2, 0.9)\nadd_edge(graph, :root => :A, 1.0)\n\n\n\n\n\n","category":"function"},{"location":"apireference/#SDDP.add_ambiguity_set","page":"API Reference","title":"SDDP.add_ambiguity_set","text":"add_ambiguity_set(graph::Graph{T}, set::Vector{T}, lipschitz::Vector{Float64})\n\nAdd set to the belief partition of graph.\n\nlipschitz is a vector of Lipschitz constants, with one element for each node in set. The Lipschitz constant is the maximum slope of the cost-to-go function with respect to the belief state associated with each node at any point in the state-space.\n\nExamples\n\ngraph = LinearGraph(3)\nadd_ambiguity_set(graph, [1, 2], [1e3, 1e2])\nadd_ambiguity_set(graph, [3], [1e5])\n\n\n\n\n\nadd_ambiguity_set(graph::Graph{T}, set::Vector{T}, lipschitz::Float64)\n\nAdd set to the belief partition of graph.\n\nlipschitz is a Lipschitz constant for each node in set. The Lipschitz constant is the maximum slope of the cost-to-go function with respect to the belief state associated with each node at any point in the state-space.\n\nExamples\n\ngraph = LinearGraph(3)\nadd_ambiguity_set(graph, [1, 2], 1e3)\nadd_ambiguity_set(graph, [3], 1e5)\n\n\n\n\n\n","category":"function"},{"location":"apireference/#SDDP.LinearGraph","page":"API Reference","title":"SDDP.LinearGraph","text":"LinearGraph(stages::Int)\n\n\n\n\n\n","category":"function"},{"location":"apireference/#SDDP.MarkovianGraph","page":"API Reference","title":"SDDP.MarkovianGraph","text":"MarkovianGraph(transition_matrices::Vector{Matrix{Float64}})\n\nConstruct a Markovian graph from the vector of transition matrices.\n\ntransition_matrices[t][i, j] gives the probability of transitioning from Markov state i in stage t - 1 to Markov state j in stage t.\n\nThe dimension of the first transition matrix should be (1, N), and transition_matrics[1][1, i] is the probability of transitioning from the root node to the Markov state i.\n\n\n\n\n\nMarkovianGraph(;\n    stages::Int,\n    transition_matrix::Matrix{Float64},\n    root_node_transition::Vector{Float64}\n)\n\nConstruct a Markovian graph object with stages number of stages and time-independent Markov transition probabilities.\n\ntransition_matrix must be a square matrix, and the probability of transitioning from Markov state i in stage t to Markov state j in stage t + 1 is given by transition_matrix[i, j].\n\nroot_node_transition[i] is the probability of transitioning from the root node to Markov state i in the first stage.\n\n\n\n\n\nMarkovianGraph(\n    simulator::Function; budget::Union{Int, Vector{Int}}, scenarios::Int = 1000\n)\n\nConstruct a Markovian graph by fitting Markov chain to scenarios generated by simulator().\n\nbudget is the total number of nodes in the resulting Markov chain. This can either be specified as a single Int, in which case we will attempt to intelligently distributed the nodes between stages. Alternatively, budget can be a Vector{Int}, which details the number of Markov state to have in each stage.\n\n\n\n\n\n","category":"function"},{"location":"apireference/#SDDP.LinearPolicyGraph","page":"API Reference","title":"SDDP.LinearPolicyGraph","text":"LinearPolicyGraph(builder::Function; stages::Int, kwargs...)\n\nCreate a linear policy graph with stages number of stages.\n\nSee SDDP.PolicyGraph for the other keyword arguments.\n\n\n\n\n\n","category":"function"},{"location":"apireference/#SDDP.MarkovianPolicyGraph","page":"API Reference","title":"SDDP.MarkovianPolicyGraph","text":"MarkovianPolicyGraph(\n    builder::Function;\n    transition_matrices::Vector{Array{Float64, 2}},\n    kwargs...\n)\n\nCreate a Markovian policy graph based on the transition matrices given in transition_matrices.\n\ntransition_matrices[t][i, j] gives the probability of transitioning from Markov state i in stage t - 1 to Markov state j in stage t.\n\nThe dimension of the first transition matrix should be (1, N), and transition_matrics[1][1, i] is the probability of transitioning from the root node to the Markov state i.\n\nSee SDDP.MarkovianGraph for other ways of specifying a Markovian policy graph. See SDDP.PolicyGraph for the other keyword arguments.\n\n\n\n\n\n","category":"function"},{"location":"apireference/#SDDP.PolicyGraph","page":"API Reference","title":"SDDP.PolicyGraph","text":"PolicyGraph(\n    builder::Function,\n    graph::Graph{T};\n    sense::Symbol = :Min,\n    lower_bound = -Inf,\n    upper_bound = Inf,\n    optimizer = nothing,\n    bellman_function = nothing,\n    direct_mode::Bool = false,\n    integrality_handler = ContinuousRelaxation(),\n) where {T}\n\nConstruct a policy graph based on the graph structure of graph. (See SDDP.Graph for details.)\n\nExample\n\nfunction builder(subproblem::JuMP.Model, index)\n    # ... subproblem definition ...\nend\n\nmodel = PolicyGraph(\n    builder,\n    graph;\n    lower_bound = 0.0,\n    optimizer = GLPK.Optimizer,\n    direct_mode = false\n)\n\nOr, using the Julia do ... end syntax:\n\nmodel = PolicyGraph(\n    graph;\n    lower_bound = 0.0,\n    optimizer = GLPK.Optimizer,\n    direct_mode = true\n) do subproblem, index\n    # ... subproblem definitions ...\nend\n\n\n\n\n\n","category":"type"},{"location":"apireference/#Subproblem-definition","page":"API Reference","title":"Subproblem definition","text":"","category":"section"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"@stageobjective\nSDDP.parameterize\nSDDP.add_objective_state\nSDDP.objective_state\nSDDP.Noise","category":"page"},{"location":"apireference/#SDDP.@stageobjective","page":"API Reference","title":"SDDP.@stageobjective","text":"@stageobjective(subproblem, expr)\n\nSet the stage-objective of subproblem to expr.\n\nExample\n\n@stageobjective(subproblem, 2x + y)\n\n\n\n\n\n","category":"macro"},{"location":"apireference/#SDDP.parameterize","page":"API Reference","title":"SDDP.parameterize","text":"parameterize(modify::Function,\n             subproblem::JuMP.Model,\n             realizations::Vector{T},\n             probability::Vector{Float64} = fill(1.0 / length(realizations))\n                 ) where T\n\nAdd a parameterization function modify to subproblem. The modify function takes one argument and modifies subproblem based on the realization of the noise sampled from realizations with corresponding probabilities probability.\n\nIn order to conduct an out-of-sample simulation, modify should accept arguments that are not in realizations (but still of type T).\n\nExample\n\nSDDP.parameterize(subproblem, [1, 2, 3], [0.4, 0.3, 0.3]) do ω\n    JuMP.set_upper_bound(x, ω)\nend\n\n\n\n\n\nparameterize(node::Node, noise)\n\nParameterize node node with the noise noise.\n\n\n\n\n\n","category":"function"},{"location":"apireference/#SDDP.add_objective_state","page":"API Reference","title":"SDDP.add_objective_state","text":"add_objective_state(update::Function, subproblem::JuMP.Model; kwargs...)\n\nAdd an objective state variable to subproblem.\n\nRequired kwargs are:\n\ninitial_value: The initial value of the objective state variable at the  root node.\nlipschitz: The lipschitz constant of the objective state variable.\n\nSetting a tight value for the lipschitz constant can significantly improve the speed of convergence.\n\nOptional kwargs are:\n\nlower_bound: A valid lower bound for the objective state variable. Can be  -Inf.\nupper_bound: A valid upper bound for the objective state variable. Can be  +Inf.\n\nSetting tight values for these optional variables can significantly improve the speed of convergence.\n\nIf the objective state is N-dimensional, each keyword argument must be an NTuple{N, Float64}. For example, initial_value = (0.0, 1.0).\n\n\n\n\n\n","category":"function"},{"location":"apireference/#SDDP.objective_state","page":"API Reference","title":"SDDP.objective_state","text":"objective_state(subproblem::JuMP.Model)\n\nReturn the current objective state of the problem.\n\nCan only be called from SDDP.parameterize.\n\n\n\n\n\n","category":"function"},{"location":"apireference/#SDDP.Noise","page":"API Reference","title":"SDDP.Noise","text":"Noise(support, probability)\n\nAn atom of a discrete random variable at the point of support support and associated probability probability.\n\n\n\n\n\n","category":"type"},{"location":"apireference/#Training-the-policy","page":"API Reference","title":"Training the policy","text":"","category":"section"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"SDDP.numerical_stability_report\nSDDP.train\nSDDP.termination_status\nSDDP.write_cuts_to_file\nSDDP.read_cuts_from_file\nSDDP.write_log_to_csv","category":"page"},{"location":"apireference/#SDDP.numerical_stability_report","page":"API Reference","title":"SDDP.numerical_stability_report","text":"numerical_stability_report([io::IO=stdout,] model::PolicyGraph,\n                           by_node::Bool=false, print=true, warn::Bool=true)\n\nPrint a report identifying possible numeric stability issues.\n\nIf by_node, print a report for each node in the graph.\nIf print, print to io.\nIf warn, warn if the coefficients may cause numerical issues.\n\n\n\n\n\n","category":"function"},{"location":"apireference/#SDDP.train","page":"API Reference","title":"SDDP.train","text":"SDDP.train(model::PolicyGraph; kwargs...)\n\nTrain the policy for model. Keyword arguments:\n\niteration_limit::Int: number of iterations to conduct before termination.\ntime_limit::Float64: number of seconds to train before termination.\nstoping_rules: a vector of SDDP.AbstractStoppingRules.\nprint_level::Int: control the level of printing to the screen. Defaults to  1. Set to 0 to disable all printing.\nlog_file::String: filepath at which to write a log of the training progress.  Defaults to SDDP.log.\nlog_frequency::Int: control the frequency with which the logging is  outputted (iterations/log). Defaults to 1.\nrun_numerical_stability_report::Bool: generate (and print) a numerical stability  report prior to solve. Defaults to true.\nrefine_at_similar_nodes::Bool: if SDDP can detect that two nodes have the  same children, it can cheaply add a cut discovered at one to the other. In  almost all cases this should be set to true.\ncut_deletion_minimum::Int: the minimum number of cuts to cache before  deleting  cuts from the subproblem. The impact on performance is solver  specific; however, smaller values result in smaller subproblems (and therefore  quicker solves), at the expense of more time spent performing cut selection.\nrisk_measure: the risk measure to use at each node. Defaults to Expectation.\nsampling_scheme: a sampling scheme to use on the forward pass of the  algorithm. Defaults to InSampleMonteCarlo.\nbackward_sampling_scheme: a backward pass sampling scheme to use on the  backward pass of the algorithm. Defaults to CompleteSampler.\ncut_type: choose between SDDP.SINGLE_CUT and SDDP.MULTI_CUT versions of SDDP.\ndashboard::Bool: open a visualization of the training over time. Defaults  to false.\nparallel_scheme::AbstractParallelScheme: specify a scheme for solving in parallel.  Defaults to Serial().\nforwad_pass::AbstractForwardPass: specify a scheme to use for the forward passes.\n\nThere is also a special option for infinite horizon problems\n\ncycle_discretization_delta: the maximum distance between states allowed on  the forward pass. This is for advanced users only and needs to be used in  conjunction with a different sampling_scheme.\n\n\n\n\n\n","category":"function"},{"location":"apireference/#SDDP.termination_status","page":"API Reference","title":"SDDP.termination_status","text":"termination_status(model::PolicyGraph)\n\nQuery the reason why the training stopped.\n\n\n\n\n\n","category":"function"},{"location":"apireference/#SDDP.write_cuts_to_file","page":"API Reference","title":"SDDP.write_cuts_to_file","text":"write_cuts_to_file(model::PolicyGraph{T}, filename::String) where {T}\n\nWrite the cuts that form the policy in model to filename in JSON format.\n\nSee also SDDP.read_cuts_from_file.\n\n\n\n\n\n","category":"function"},{"location":"apireference/#SDDP.read_cuts_from_file","page":"API Reference","title":"SDDP.read_cuts_from_file","text":"read_cuts_from_file(\n    model::PolicyGraph{T}, filename::String;\n    node_name_parser::Function = _node_name_parser) where {T}\n\nRead cuts (saved using SDDP.write_cuts_to_file) from filename into model.\n\nSince T can be an arbitrary Julia type, the conversion to JSON is lossy. When reading, read_cuts_from_file only supports T=Int, T=NTuple{N, Int}, and T=Symbol. If you have manually created a policy graph with a different node type T, provide a function node_name_parser with the signature node_name_parser(T, name::String)::T where {T} that returns the name of each node given the string name name.\n\nSee also SDDP.write_cuts_to_file.\n\n\n\n\n\n","category":"function"},{"location":"apireference/#SDDP.write_log_to_csv","page":"API Reference","title":"SDDP.write_log_to_csv","text":"write_log_to_csv(model::PolicyGraph, filename::String)\n\nWrite the log of the most recent training to a csv for post-analysis.\n\nAssumes that the model has been trained via SDDP.train.\n\n\n\n\n\n","category":"function"},{"location":"apireference/#Stopping-rules","page":"API Reference","title":"Stopping rules","text":"","category":"section"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"SDDP.AbstractStoppingRule\nSDDP.stopping_rule_status\nSDDP.convergence_test","category":"page"},{"location":"apireference/#SDDP.AbstractStoppingRule","page":"API Reference","title":"SDDP.AbstractStoppingRule","text":"AbstractStoppingRule\n\nThe abstract type for the stopping-rule interface.\n\nYou need to define the following methods:\n\nSDDP.stopping_rule_status\nSDDP.convergence_test\n\n\n\n\n\n","category":"type"},{"location":"apireference/#SDDP.stopping_rule_status","page":"API Reference","title":"SDDP.stopping_rule_status","text":"stopping_rule_status(::AbstractStoppingRule)::Symbol\n\nReturn a symbol describing the stopping rule.\n\n\n\n\n\n","category":"function"},{"location":"apireference/#SDDP.convergence_test","page":"API Reference","title":"SDDP.convergence_test","text":"convergence_test(model::PolicyGraph, log::Vector{Log}, ::AbstractStoppingRule)::Bool\n\nReturn a Bool indicating if the algorithm should terminate the training.\n\n\n\n\n\n","category":"function"},{"location":"apireference/#Sampling-schemes","page":"API Reference","title":"Sampling schemes","text":"","category":"section"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"SDDP.AbstractSamplingScheme\nSDDP.sample_scenario\nSDDP.InSampleMonteCarlo\nSDDP.OutOfSampleMonteCarlo","category":"page"},{"location":"apireference/#SDDP.AbstractSamplingScheme","page":"API Reference","title":"SDDP.AbstractSamplingScheme","text":"AbstractSamplingScheme\n\nThe abstract type for the sampling-scheme interface.\n\nYou need to define the following methods:\n\nSDDP.sample_scenario\n\n\n\n\n\n","category":"type"},{"location":"apireference/#SDDP.sample_scenario","page":"API Reference","title":"SDDP.sample_scenario","text":"sample_scenario(graph::PolicyGraph{T}, ::AbstractSamplingScheme) where T\n\nSample a scenario from the policy graph graph based on the sampling scheme.\n\nReturns ::Tuple{Vector{Tuple{T, <:Any}}, Bool}, where the first element is the scenario, and the second element is a Boolean flag indicating if the scenario was terminated due to the detection of a cycle.\n\nThe scenario is a list of tuples (type Vector{Tuple{T, <:Any}}) where the first component of each tuple is the index of the node, and the second component is the stagewise-independent noise term observed in that node.\n\n\n\n\n\n","category":"function"},{"location":"apireference/#SDDP.InSampleMonteCarlo","page":"API Reference","title":"SDDP.InSampleMonteCarlo","text":"InSampleMonteCarlo(;\n    max_depth::Int = 0,\n    terminate_on_cycle::Function = false,\n    terminate_on_dummy_leaf::Function = true,\n    rollout_limit::Function = (i::Int) -> typemax(Int)\n)\n\nA Monte Carlo sampling scheme using the in-sample data from the policy graph definition.\n\nIf terminate_on_cycle, terminate the forward pass once a cycle is detected. If max_depth > 0, return once max_depth nodes have been sampled. If terminate_on_dummy_leaf, terminate the forward pass with 1 - probability of sampling a child node.\n\nNote that if terminate_on_cycle = false and terminate_on_dummy_leaf = false then max_depth must be set > 0.\n\nYou can use rollout_limit to set iteration specific depth limits. For example:\n\nInSampleMonteCarlo(rollout_limit = i -> 2 * i)\n\n\n\n\n\n","category":"type"},{"location":"apireference/#SDDP.OutOfSampleMonteCarlo","page":"API Reference","title":"SDDP.OutOfSampleMonteCarlo","text":"OutOfSampleMonteCarlo(\n    f::Function, graph::PolicyGraph;\n    use_insample_transition::Bool = false,\n    max_depth::Int = 0,\n    terminate_on_cycle::Bool = false,\n    terminate_on_dummy_leaf::Bool = true,\n    rollout_limit::Function = i -> typemax(Int),\n)\n\nCreate a Monte Carlo sampler using out-of-sample probabilities and/or supports for the stagewise-independent noise terms, and out-of-sample probabilities for the node-transition matrix.\n\nf is a function that takes the name of a node and returns a tuple containing a vector of new SDDP.Noise terms for the children of that node, and a vector of new SDDP.Noise terms for the stagewise-independent noise.\n\nIf f is called with the name of the root node (e.g., 0 in a linear policy graph, (0, 1) in a Markovian Policy Graph), then return a vector of SDDP.Noise for the children of the root node.\n\nIf use_insample_transition, the in-sample transition probabilities will be used. Therefore, f should only return a vector of the stagewise-independent noise terms, and f will not be called for the root node.\n\nIf terminate_on_cycle, terminate the forward pass once a cycle is detected. If max_depth > 0, return once max_depth nodes have been sampled. If terminate_on_dummy_leaf, terminate the forward pass with 1 - probability of sampling a child node.\n\nNote that if terminate_on_cycle = false and terminate_on_dummy_leaf = false then max_depth must be set > 0.\n\nYou can use rollout_limit to set iteration specific depth limits. For example:\n\nOutOfSampleMonteCarlo(rollout_limit = i -> 2 * i)\n\nExample\n\n# Given linear policy graph `graph` with `T` stages:\nsampler = OutOfSampleMonteCarlo(graph) do node\n    if node == 0\n        return [SDDP.Noise(1, 1.0)]\n    else\n        noise_terms = [SDDP.Noise(node, 0.3), SDDP.Noise(node + 1, 0.7)]\n        children = node < T ? [SDDP.Noise(node + 1, 0.9)] : SDDP.Noise{Int}[]\n        return children, noise_terms\n    end\nend\n\n# Given linear policy graph `graph` with `T` stages:\nsampler = OutOfSampleMonteCarlo(graph, use_insample_transition=true) do node\n    return [SDDP.Noise(node, 0.3), SDDP.Noise(node + 1, 0.7)]\nend\n\n\n\n\n\n","category":"type"},{"location":"apireference/#Parallel-schemes","page":"API Reference","title":"Parallel schemes","text":"","category":"section"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"SDDP.AbstractParallelScheme\nSDDP.Serial\nSDDP.Asynchronous","category":"page"},{"location":"apireference/#SDDP.AbstractParallelScheme","page":"API Reference","title":"SDDP.AbstractParallelScheme","text":"AbstractParallelScheme\n\nAbstract type for different parallelism schemes.\n\n\n\n\n\n","category":"type"},{"location":"apireference/#SDDP.Serial","page":"API Reference","title":"SDDP.Serial","text":"Serial()\n\nRun SDDP in serial mode.\n\n\n\n\n\n","category":"type"},{"location":"apireference/#SDDP.Asynchronous","page":"API Reference","title":"SDDP.Asynchronous","text":"Asynchronous(init_callback::Function, slave_pids::Vector{Int} = workers())\n\nRun SDDP in asynchronous mode workers with pid's slave_pids.\n\nAfter initializing the models on each worker, call init_callback(model). Note that init_callback is run locally on the worker and not on the master thread.\n\n\n\n\n\nAsynchronous(slave_pids::Vector{Int} = workers())\n\nRun SDDP in asynchronous mode workers with pid's slave_pids.\n\n\n\n\n\n","category":"type"},{"location":"apireference/#Forward-passes","page":"API Reference","title":"Forward passes","text":"","category":"section"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"SDDP.AbstractForwardPass\nSDDP.DefaultForwardPass\nSDDP.RevisitingForwardPass","category":"page"},{"location":"apireference/#SDDP.AbstractForwardPass","page":"API Reference","title":"SDDP.AbstractForwardPass","text":"AbstractForwardPass\n\nAbstract type for different forward passes.\n\n\n\n\n\n","category":"type"},{"location":"apireference/#SDDP.DefaultForwardPass","page":"API Reference","title":"SDDP.DefaultForwardPass","text":"DefaultForwardPass()\n\nThe default forward pass.\n\n\n\n\n\n","category":"type"},{"location":"apireference/#SDDP.RevisitingForwardPass","page":"API Reference","title":"SDDP.RevisitingForwardPass","text":"RevisitingForwardPass(\n    period::Int = 500;\n    sub_pass::AbstractForwardPass = DefaultForwardPass()\n)\n\nA forward pass scheme that generate period new forward passes (using sub_pass), then revisits all previously explored forward passes. This can be useful to encourage convergence at a diversity of points in the state-space.\n\nSet period = typemax(Int) to disable.\n\nFor example, if period = 2, then the forward passes will be revisited as follows: 1, 2, 1, 2, 3, 4, 1, 2, 3, 4, 5, 6, 1, 2, ....\n\n\n\n\n\n","category":"type"},{"location":"apireference/#Risk-Measures","page":"API Reference","title":"Risk Measures","text":"","category":"section"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"SDDP.AbstractRiskMeasure\nSDDP.adjust_probability","category":"page"},{"location":"apireference/#SDDP.AbstractRiskMeasure","page":"API Reference","title":"SDDP.AbstractRiskMeasure","text":"AbstractRiskMeasure\n\nThe abstract type for the risk measure interface.\n\nYou need to define the following methods:\n\nSDDP.adjust_probability\n\n\n\n\n\n","category":"type"},{"location":"apireference/#SDDP.adjust_probability","page":"API Reference","title":"SDDP.adjust_probability","text":"adjust_probability(measure::Expectation\n                   risk_adjusted_probability::Vector{Float64},\n                   original_probability::Vector{Float64},\n                   noise_support::Vector{Noise{T}},\n                   objective_realizations::Vector{Float64},\n                   is_minimization::Bool) where T\n\n\n\n\n\n","category":"function"},{"location":"apireference/#Integrality-handlers","page":"API Reference","title":"Integrality handlers","text":"","category":"section"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"SDDP.AbstractIntegralityHandler\nSDDP.ContinuousRelaxation\nSDDP.SDDiP","category":"page"},{"location":"apireference/#SDDP.AbstractIntegralityHandler","page":"API Reference","title":"SDDP.AbstractIntegralityHandler","text":"AbstractIntegralityHandler\n\nThe abstract type for the integrality handlers interface.\n\n\n\n\n\n","category":"type"},{"location":"apireference/#SDDP.ContinuousRelaxation","page":"API Reference","title":"SDDP.ContinuousRelaxation","text":"ContinuousRelaxation()\n\nThe continuous relaxation integrality handler. Duals are obtained in the backward pass by solving a continuous relaxation of each subproblem. Integrality constraints are retained in policy simulation.\n\n\n\n\n\n","category":"type"},{"location":"apireference/#SDDP.SDDiP","page":"API Reference","title":"SDDP.SDDiP","text":"SDDiP(; iteration_limit::Int = 100, atol::Float64, rtol::Float64)\n\nThe SDDiP integrality handler introduced by Zou, J., Ahmed, S. & Sun, X.A. Math. Program. (2019) 175: 461. Stochastic dual dynamic integer programming. https://doi.org/10.1007/s10107-018-1249-5.\n\nCalculates duals by solving the Lagrangian dual for each subproblem. Kelley's method is used to compute Lagrange multipliers. iteration_limit controls the maximum number of iterations, and atol and rtol are the absolute and relative tolerances used in the termination criteria.\n\nAll state variables are assumed to take nonnegative values only.\n\n\n\n\n\n","category":"type"},{"location":"apireference/#Simulating-the-policy","page":"API Reference","title":"Simulating the policy","text":"","category":"section"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"SDDP.simulate\nSDDP.calculate_bound\nSDDP.Historical","category":"page"},{"location":"apireference/#SDDP.simulate","page":"API Reference","title":"SDDP.simulate","text":"simulate(\n    model::PolicyGraph,\n    number_replications::Int = 1,\n    variables::Vector{Symbol} = Symbol[];\n    sampling_scheme::AbstractSamplingScheme =\n        InSampleMonteCarlo(),\n    custom_recorders = Dict{Symbol, Function}(),\n    require_duals::Bool = true,\n    skip_undefined_variables::Bool = false,\n    parallel_scheme::AbstractParallelScheme = Serial()\n )::Vector{Vector{Dict{Symbol, Any}}}\n\nPerform a simulation of the policy model with number_replications replications using the sampling scheme sampling_scheme.\n\nReturns a vector with one element for each replication. Each element is a vector with one-element for each node in the scenario that was sampled. Each element in that vector is a dictionary containing information about the subproblem that was solved.\n\nIn that dictionary there are four special keys:\n\n:node_index, which records the index of the sampled node in the policy model\n:noise_term, which records the noise observed at the node\n:stage_objective, which records the stage-objective of the subproblem\n:bellman_term, which records the cost/value-to-go of the node.\n\nThe sum of :stageobjective + :bellmanterm will equal the objective value of the solved subproblem.\n\nIn addition to the special keys, the dictionary will contain the result of JuMP.value(subproblem[key]) for each key in variables. This is useful to obtain the primal value of the state and control variables.\n\nFor more complicated data, the custom_recorders keyword argument can be used.\n\ndata = Dict{Symbol, Any}()\nfor (key, recorder) in custom_recorders\n    data[key] = foo(subproblem)\nend\n\nFor example, to record the dual of a constraint named my_constraint, pass the following:\n\nsimulation_results = SDDP.simulate(model, 2;\n    custom_recorders = Dict{Symbol, Function}(\n        :constraint_dual => (sp) -> JuMP.dual(sp[:my_constraint])\n    )\n)\n\nThe value of the dual in the first stage of the second replication can be accessed as:\n\nsimulation_results[2][1][:constraint_dual]\n\nIf you do not require dual variables (or if they are not available), pass require_duals = false.\n\nIf you attempt to simulate the value of a variable that is only defined in some of the stage problems, an error will be thrown. To over-ride this (and return a NaN instead), pass skip_undefined_variables = true.\n\nUse parallel_scheme::[AbstractParallelScheme](@ref) to specify a scheme for simulating in parallel. Defaults to Serial.\n\n\n\n\n\n","category":"function"},{"location":"apireference/#SDDP.calculate_bound","page":"API Reference","title":"SDDP.calculate_bound","text":"SDDP.calculate_bound(model::PolicyGraph, state::Dict{Symbol, Float64},\n                       risk_measure=Expectation())\n\nCalculate the lower bound (if minimizing, otherwise upper bound) of the problem model at the point state, assuming the risk measure at the root node is risk_measure.\n\n\n\n\n\n","category":"function"},{"location":"apireference/#SDDP.Historical","page":"API Reference","title":"SDDP.Historical","text":"Historical(scenarios::Vector{Vector{Tuple{T, S}}},\n           probability::Vector{Float64})\n\nA sampling scheme that samples a scenario from the vector of scenarios scenarios according to probability. If probability omitted, defaults to uniform probability.\n\nExample\n\nHistorical(\n    [\n        [(1, 0.5), (2, 1.0), (3, 0.5)],\n        [(1, 0.5), (2, 0.0), (3, 1.0)],\n        [(1, 1.0), (2, 0.0), (3, 0.0)]\n    ],\n    [0.2, 0.5, 0.3]\n)\n\n\n\n\n\nHistorical(scenario::Vector{Tuple{T, S}})\n\nA deterministic sampling scheme that always samples scenario with probability 1.\n\nExample\n\nHistorical([(1, 0.5), (2, 1.5), (3, 0.75)])\n\n\n\n\n\n","category":"type"},{"location":"apireference/#Decision-rules","page":"API Reference","title":"Decision rules","text":"","category":"section"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"SDDP.DecisionRule\nSDDP.evaluate","category":"page"},{"location":"apireference/#SDDP.DecisionRule","page":"API Reference","title":"SDDP.DecisionRule","text":"DecisionRule(model::PolicyGraph{T}; node::T)\n\nCreate a decision rule for node node in model.\n\n\n\n\n\n","category":"type"},{"location":"apireference/#SDDP.evaluate","page":"API Reference","title":"SDDP.evaluate","text":"evaluate(\n    rule::DecisionRule;\n    incoming_state::Dict{Symbol, Float64},\n    noise = nothing,\n    controls_to_record = Symbol[],\n)\n\nEvalute the decision rule rule at the point described by the incoming_state and noise.\n\nIf the node is deterministic, omit the noise argument.\n\nPass a list of symbols to controls_to_record to save the optimal primal solution corresponding to the names registered in the model.\n\n\n\n\n\nevaluate(\n    V::ValueFunction,\n    point::Dict{Symbol, Float64},\n    objective_state = nothing,\n    belief_state = nothing\n)\n\nEvaluate the value function V at point in the state-space.\n\nReturns a tuple containing the height of the function, and the subgradient w.r.t. the convex state-variables.\n\n\n\n\n\nevalute(V::ValueFunction{Nothing, Nothing}; kwargs...)\n\nEvalute the value function V at the point in the state-space specified by kwargs.\n\nExample\n\nevaluate(V; volume = 1)\n\n\n\n\n\nevaluate(\n    model::PolicyGraph{T}, test_scenarios::TestScenarios{T, S}\n) where {T, S}\n\nEvaluate the performance of the policy contained in model after a call to train on the scenarios specified by test_scenarios.\n\nExample\n\nmodel, test_scenarios = read_from_file(\"my_model.sof.json\")\ntrain(model; iteration_limit = 100)\nsimulations = evaluate(model, test_scenarios)\n\n\n\n\n\n","category":"function"},{"location":"apireference/#Visualizing-the-policy","page":"API Reference","title":"Visualizing the policy","text":"","category":"section"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"SDDP.SpaghettiPlot\nSDDP.add_spaghetti\nSDDP.publication_plot\nSDDP.ValueFunction\nSDDP.evaluate(::SDDP.ValueFunction, ::Dict{Symbol,Float64})\nSDDP.plot","category":"page"},{"location":"apireference/#SDDP.SpaghettiPlot","page":"API Reference","title":"SDDP.SpaghettiPlot","text":"SDDP.SpaghettiPlot(; stages, scenarios)\n\nInitialize a new SpaghettiPlot with stages stages and scenarios number of replications.\n\n\n\n\n\n","category":"type"},{"location":"apireference/#SDDP.add_spaghetti","page":"API Reference","title":"SDDP.add_spaghetti","text":"SDDP.add_spaghetti(data_function::Function, plt::SpaghettiPlot; kwargs...)\n\nDescription\n\nAdd a new figure to the SpaghettiPlot plt, where the y-value of the scenarioth line when x = stage is given by data_function(plt.simulations[scenario][stage]).\n\nKeyword arguments\n\nxlabel: set the xaxis label\nylabel: set the yaxis label\ntitle: set the title of the plot\nymin: set the minimum y value\nymax: set the maximum y value\ncumulative: plot the additive accumulation of the value across the stages\ninterpolate: interpolation method for lines between stages.\n\nDefaults to \"linear\" see the d3 docs \tfor all options.\n\nExamples\n\nsimulations = simulate(model, 10)\nplt = SDDP.spaghetti_plot(simulations)\nSDDP.add_spaghetti(plt; title = \"Stage objective\") do data\n\treturn data[:stage_objective]\nend\n\n\n\n\n\n","category":"function"},{"location":"apireference/#SDDP.publication_plot","page":"API Reference","title":"SDDP.publication_plot","text":"SDDP.publication_plot(\n    data_function, simulations;\n    quantile = [0.0, 0.1, 0.25, 0.5, 0.75, 0.9, 1.0],\n    kwargs...)\n\nCreate a Plots.jl recipe plot of the simulations.\n\nSee Plots.jl for the list of keyword arguments.\n\nExample\n\nSDDP.publication_plot(simulations; title = \"My title\") do data\n    return data[:stage_objective]\nend\n\n\n\n\n\n","category":"function"},{"location":"apireference/#SDDP.ValueFunction","page":"API Reference","title":"SDDP.ValueFunction","text":"ValueFunction\n\nA representation of the value function. SDDP.jl uses the following unique representation of the value function that is undocumented in the literature.\n\nIt supports three types of state variables:\n\nx - convex \"resource\" states\nb - concave \"belief\" states\ny - concave \"objective\" states\n\nIn addition, we have three types of cuts:\n\nSingle-cuts (also called \"average\" cuts in the literature), which involve the risk-adjusted expectation of the cost-to-go.\nMulti-cuts, which use a different cost-to-go term for each realization w.\nRisk-cuts, which correspond to the facets of the dual interpretation of a coherent risk measure.\n\nTherefore, ValueFunction returns a JuMP model of the following form:\n\nV(x, b, y) = min: μᵀb + νᵀy + θ\n             s.t. # \"Single\" / \"Average\" cuts\n                  μᵀb(j) + νᵀy(j) + θ >= α(j) + xᵀβ(j), ∀ j ∈ J\n                  # \"Multi\" cuts\n                  μᵀb(k) + νᵀy(k) + φ(w) >= α(k, w) + xᵀβ(k, w), ∀w ∈ Ω, k ∈ K\n                  # \"Risk-set\" cuts\n                  θ ≥ Σ{p(k, w) * φ(w)}_w - μᵀb(k) - νᵀy(k), ∀ k ∈ K\n\n\n\n\n\n","category":"type"},{"location":"apireference/#SDDP.evaluate-Tuple{SDDP.ValueFunction,Dict{Symbol,Float64}}","page":"API Reference","title":"SDDP.evaluate","text":"evaluate(\n    V::ValueFunction,\n    point::Dict{Symbol, Float64},\n    objective_state = nothing,\n    belief_state = nothing\n)\n\nEvaluate the value function V at point in the state-space.\n\nReturns a tuple containing the height of the function, and the subgradient w.r.t. the convex state-variables.\n\n\n\n\n\n","category":"method"},{"location":"apireference/#SDDP.plot","page":"API Reference","title":"SDDP.plot","text":"plot(plt::SpaghettiPlot[, filename::String]; open::Bool = true)\n\nThe SpaghettiPlot plot plt to filename. If filename is not given, it will be saved to a temporary directory. If open = true, then a browser window will be opened to display the resulting HTML file.\n\n\n\n\n\n","category":"function"},{"location":"apireference/#Debugging-the-model","page":"API Reference","title":"Debugging the model","text":"","category":"section"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"SDDP.write_subproblem_to_file\nSDDP.deterministic_equivalent","category":"page"},{"location":"apireference/#SDDP.write_subproblem_to_file","page":"API Reference","title":"SDDP.write_subproblem_to_file","text":"write_subproblem_to_file(node::Node, filename::String; throw_error::Bool = false)\n\nWrite the subproblem contained in node to the file filename.\n\n\n\n\n\n","category":"function"},{"location":"apireference/#SDDP.deterministic_equivalent","page":"API Reference","title":"SDDP.deterministic_equivalent","text":"deterministic_equivalent(\n    pg::PolicyGraph{T},\n    optimizer = nothing;\n    time_limit::Union{Real, Nothing} = 60.0\n)\n\nForm a JuMP model that represents the deterministic equivalent of the problem.\n\nExamples\n\ndeterministic_equivalent(model)\ndeterministic_equivalent(model, GLPK.Optimizer)\n\n\n\n\n\n","category":"function"},{"location":"apireference/#StochOptFormat","page":"API Reference","title":"StochOptFormat","text":"","category":"section"},{"location":"apireference/","page":"API Reference","title":"API Reference","text":"SDDP.write_to_file\nSDDP.read_from_file\nBase.write(::IO, ::SDDP.PolicyGraph)\nBase.read(::IO, ::Type{SDDP.PolicyGraph})\nSDDP.evaluate(::SDDP.PolicyGraph{T}, ::SDDP.TestScenarios{T}) where {T}\nSDDP.TestScenarios\nSDDP.TestScenario","category":"page"},{"location":"apireference/#SDDP.write_to_file","page":"API Reference","title":"SDDP.write_to_file","text":"write_to_file(\n    model::PolicyGraph,\n    filename::String;\n    compression::MOI.FileFormats.AbstractCompressionScheme =\n        MOI.FileFormats.AutomaticCompression(),\n    kwargs...\n)\n\nWrite model to filename in the StochOptFormat file format.\n\nPass an argument to compression to override the default of automatically detecting the file compression to use based on the extension of filename.\n\nSee Base.write(::IO, ::PolicyGraph) for information on the keyword arguments that can be provided.\n\nWARNING: THIS FUNCTION IS EXPERIMENTAL. SEE THE FULL WARNING IN Base.write(::IO, ::PolicyGraph).\n\nExample\n\nwrite_to_file(model, \"my_model.sof.json\"; test_scenarios = 10)\n\n\n\n\n\n","category":"function"},{"location":"apireference/#SDDP.read_from_file","page":"API Reference","title":"SDDP.read_from_file","text":"read_from_file(\n    filename::String;\n    compression::MOI.FileFormats.AbstractCompressionScheme =\n        MOI.FileFormats.AutomaticCompression(),\n    kwargs...\n)::Tuple{PolicyGraph, TestScenarios}\n\nReturn a tuple containing a PolicyGraph object and a TestScenarios read from filename in the StochOptFormat file format.\n\nPass an argument to compression to override the default of automatically detecting the file compression to use based on the extension of filename.\n\nSee Base.read(::IO, ::Type{PolicyGraph}) for information on the keyword arguments that can be provided.\n\nWARNING: THIS FUNCTION IS EXPERIMENTAL. SEE THE FULL WARNING IN Base.read(::IO, ::Type{PolicyGraph}).\n\nExample\n\nmodel, test_scenarios = read_from_file(\"my_model.sof.json\")\n\n\n\n\n\n","category":"function"},{"location":"apireference/#Base.write-Tuple{IO,SDDP.PolicyGraph}","page":"API Reference","title":"Base.write","text":"Base.write(\n    io::IO,\n    model::PolicyGraph;\n    test_scenarios::Union{Int, TestScenarios} = 1_000,\n    kwargs...\n)\n\nWrite model to io in the StochOptFormat file format.\n\nPass an Int to test_scenarios (default 1_000) to specify the number of test scenarios to generate using the InSampleMonteCarlo sampling scheme. Alternatively, pass a TestScenarios object to manually specify the test scenarios to use.\n\nAny additional kwargs passed to write will be stored in the top-level of the resulting StochOptFormat file. Valid arguments include name, author, date, and description.\n\nWARNING: THIS FUNCTION IS EXPERIMENTAL. THINGS MAY CHANGE BETWEEN COMMITS. YOU SHOULD NOT RELY ON THIS FUNCTIONALITY AS A LONG-TERM FILE FORMAT (YET).\n\nIn addition to potential changes to the underlying format, only a subset of possible modifications are supported. These include:\n\nJuMP.fix\nJuMP.set_lower_bound\nJuMP.set_upper_bound\nJuMP.set_normalized_rhs\nChanges to the constant or affine terms in a stage objective\n\nIf your model uses something other than this, this function will silently write an incorrect formulation of the problem.\n\nExample\n\nopen(\"my_model.sof.json\", \"w\") do io\n    write(\n        io,\n        model;\n        test_scenarios = 10,\n        name = \"MyModel\",\n        author = \"@odow\",\n        date = \"2020-07-20\",\n        description = \"Example problem for the SDDP.jl documentation\",\n    )\nend\n\n\n\n\n\n","category":"method"},{"location":"apireference/#Base.read-Tuple{IO,Type{SDDP.PolicyGraph}}","page":"API Reference","title":"Base.read","text":"Base.read(\n    io::IO,\n    ::Type{PolicyGraph};\n    bound::Float64 = 1e6,\n)::Tuple{PolicyGraph, TestScenarios}\n\nReturn a tuple containing a PolicyGraph object and a TestScenarios read from io in the StochOptFormat file format.\n\nSee also: evaluate.\n\nWARNING: THIS FUNCTION IS EXPERIMENTAL. THINGS MAY CHANGE BETWEEN COMMITS. YOU SHOULD NOT RELY ON THIS FUNCTIONALITY AS A LONG-TERM FILE FORMAT (YET).\n\nIn addition to potential changes to the underlying format, only a subset of possible modifications are supported. These include:\n\nAdditive random variables in the constraints or in the objective\nMultiplicative random variables in the objective\n\nIf your model uses something other than this, this function may throw an error or silently build a non-convex model.\n\nExample\n\nopen(\"my_model.sof.json\", \"r\") do io\n    model, test_scenarios = read(io, PolicyGraph)\nend\n\n\n\n\n\n","category":"method"},{"location":"apireference/#SDDP.evaluate-Union{Tuple{T}, Tuple{PolicyGraph{T},TestScenarios{T,S} where S}} where T","page":"API Reference","title":"SDDP.evaluate","text":"evaluate(\n    model::PolicyGraph{T}, test_scenarios::TestScenarios{T, S}\n) where {T, S}\n\nEvaluate the performance of the policy contained in model after a call to train on the scenarios specified by test_scenarios.\n\nExample\n\nmodel, test_scenarios = read_from_file(\"my_model.sof.json\")\ntrain(model; iteration_limit = 100)\nsimulations = evaluate(model, test_scenarios)\n\n\n\n\n\n","category":"method"},{"location":"apireference/#SDDP.TestScenarios","page":"API Reference","title":"SDDP.TestScenarios","text":"TestScenarios{T, S}(scenarios::Vector{TestScenario{T, S}})\n\nAn AbstractSamplingScheme based on a vector of scenarios.\n\nEach scenario is a vector of Tuple{T, S} where the first element is the node to visit and the second element is the realization of the stagewise-independent noise term. Pass nothing if the node is deterministic.\n\n\n\n\n\n","category":"type"},{"location":"apireference/#SDDP.TestScenario","page":"API Reference","title":"SDDP.TestScenario","text":"TestScenario{T, S}(probability::Float64, scenario::Vector{Tuple{T, S}})\n\nA single scenario for testing.\n\nSee also: TestScenarios.\n\n\n\n\n\n","category":"type"},{"location":"guides/choose_a_stopping_rule/#Choose-a-stopping-rule","page":"Choose a stopping rule","title":"Choose a stopping rule","text":"","category":"section"},{"location":"guides/choose_a_stopping_rule/","page":"Choose a stopping rule","title":"Choose a stopping rule","text":"The theory of SDDP tells us that the algorithm converges to an optimal policy almost surely in a finite number of iterations. In practice, this number is very large. Therefore, we need some way of pre-emptively terminating SDDP when the solution is “good enough.” We call heuristics for pre-emptively terminating SDDP stopping rules.","category":"page"},{"location":"guides/choose_a_stopping_rule/#Basic-limits","page":"Choose a stopping rule","title":"Basic limits","text":"","category":"section"},{"location":"guides/choose_a_stopping_rule/","page":"Choose a stopping rule","title":"Choose a stopping rule","text":"The training of an SDDP policy can be terminated after a fixed number of iterations using the iteration_limit keyword.","category":"page"},{"location":"guides/choose_a_stopping_rule/","page":"Choose a stopping rule","title":"Choose a stopping rule","text":"SDDP.train(model, iteration_limit = 10)","category":"page"},{"location":"guides/choose_a_stopping_rule/","page":"Choose a stopping rule","title":"Choose a stopping rule","text":"The training of an SDDP policy can be terminated after a fixed number of seconds using the time_limit keyword.","category":"page"},{"location":"guides/choose_a_stopping_rule/","page":"Choose a stopping rule","title":"Choose a stopping rule","text":"SDDP.train(model, time_limit = 2.0)","category":"page"},{"location":"guides/choose_a_stopping_rule/#Stopping-rules","page":"Choose a stopping rule","title":"Stopping rules","text":"","category":"section"},{"location":"guides/choose_a_stopping_rule/","page":"Choose a stopping rule","title":"Choose a stopping rule","text":"In addition to the limits provided as keyword arguments, a variety of other stopping rules are available. These can be passed to SDDP.train as a vector to the stopping_rules keyword. For example:","category":"page"},{"location":"guides/choose_a_stopping_rule/","page":"Choose a stopping rule","title":"Choose a stopping rule","text":"SDDP.train(model, stopping_rules = [SDDP.BoundStalling(10, 1e-4)])","category":"page"},{"location":"guides/choose_a_stopping_rule/","page":"Choose a stopping rule","title":"Choose a stopping rule","text":"Here are the stopping rules implemented in SDDP.jl:","category":"page"},{"location":"guides/choose_a_stopping_rule/","page":"Choose a stopping rule","title":"Choose a stopping rule","text":"SDDP.IterationLimit\nSDDP.TimeLimit\nSDDP.Statistical\nSDDP.BoundStalling","category":"page"},{"location":"guides/choose_a_stopping_rule/#SDDP.IterationLimit","page":"Choose a stopping rule","title":"SDDP.IterationLimit","text":"IterationLimit(limit::Int)\n\nTeriminate the algorithm after limit number of iterations.\n\n\n\n\n\n","category":"type"},{"location":"guides/choose_a_stopping_rule/#SDDP.TimeLimit","page":"Choose a stopping rule","title":"SDDP.TimeLimit","text":"TimeLimit(limit::Float64)\n\nTeriminate the algorithm after limit seconds of computation.\n\n\n\n\n\n","category":"type"},{"location":"guides/choose_a_stopping_rule/#SDDP.Statistical","page":"Choose a stopping rule","title":"SDDP.Statistical","text":"Statistical(; num_replications, iteration_period = 1, z_score = 1.96,\n            verbose = true)\n\nPerform an in-sample Monte Carlo simulation of the policy with num_replications replications every iteration_periods. Terminate if the deterministic bound (lower if minimizing) calls into the confidence interval for the mean of the simulated cost. If verbose = true, print the confidence interval.\n\nNote that this tests assumes that the simulated values are normally distributed. In infinite horizon models, this is almost never the case. The distribution is usually closer to exponential or log-normal.\n\n\n\n\n\n","category":"type"},{"location":"guides/choose_a_stopping_rule/#SDDP.BoundStalling","page":"Choose a stopping rule","title":"SDDP.BoundStalling","text":"BoundStalling(num_previous_iterations::Int, tolerance::Float64)\n\nTeriminate the algorithm once the deterministic bound (lower if minimizing, upper if maximizing) fails to improve by more than tolerance in absolute terms for more than num_previous_iterations consecutve iterations.\n\n\n\n\n\n","category":"type"},{"location":"guides/add_noise_in_the_constraint_matrix/#Add-noise-in-the-constraint-matrix","page":"Add noise in the constraint matrix","title":"Add noise in the constraint matrix","text":"","category":"section"},{"location":"guides/add_noise_in_the_constraint_matrix/","page":"Add noise in the constraint matrix","title":"Add noise in the constraint matrix","text":"DocTestSetup = quote\n    using SDDP, GLPK\nend","category":"page"},{"location":"guides/add_noise_in_the_constraint_matrix/","page":"Add noise in the constraint matrix","title":"Add noise in the constraint matrix","text":"SDDP.jl supports coefficients in the constraint matrix through the JuMP.set_normalized_coefficient function.","category":"page"},{"location":"guides/add_noise_in_the_constraint_matrix/","page":"Add noise in the constraint matrix","title":"Add noise in the constraint matrix","text":"julia> model = SDDP.LinearPolicyGraph(\n               stages=3, lower_bound = 0, optimizer = GLPK.Optimizer\n               ) do subproblem, t\n           @variable(subproblem, x, SDDP.State, initial_value = 0.0)\n           @constraint(subproblem, emissions, 1x.out <= 1)\n           SDDP.parameterize(subproblem, [0.2, 0.5, 1.0]) do ω\n               JuMP.set_normalized_coefficient(emissions, x.out, ω)\n               println(emissions)\n           end\n           @stageobjective(subproblem, -x.out)\n       end\nA policy graph with 3 nodes.\n Node indices: 1, 2, 3\n\njulia> SDDP.simulate(model, 1);\nemissions : x_out <= 1.0\nemissions : 0.2 x_out <= 1.0\nemissions : 0.5 x_out <= 1.0","category":"page"},{"location":"guides/add_noise_in_the_constraint_matrix/","page":"Add noise in the constraint matrix","title":"Add noise in the constraint matrix","text":"note: Note\nJuMP will normalize constraints by moving all variables to the left-hand side. Thus, @constraint(model, 0 <= 1 - x.out) becomes x.out <= 1. JuMP.set_normalized_coefficient sets the coefficient on the normalized constraint.","category":"page"},{"location":"tutorial/05_plotting/","page":"Basic V: plotting","title":"Basic V: plotting","text":"EditURL = \"https://github.com/odow/SDDP.jl/blob/master/docs/src/tutorial/05_plotting.jl\"","category":"page"},{"location":"tutorial/05_plotting/#Basic-V:-plotting","page":"Basic V: plotting","title":"Basic V: plotting","text":"","category":"section"},{"location":"tutorial/05_plotting/","page":"Basic V: plotting","title":"Basic V: plotting","text":"In our previous tutorials, we formulated, solved, and simulated multistage stochastic optimization problems. However, we haven't really investigated what the solution looks like. Luckily, SDDP.jl includes a number of plotting tools to help us do that. In this tutorial, we explain the tools and make some pretty pictures.","category":"page"},{"location":"tutorial/05_plotting/#Preliminaries","page":"Basic V: plotting","title":"Preliminaries","text":"","category":"section"},{"location":"tutorial/05_plotting/","page":"Basic V: plotting","title":"Basic V: plotting","text":"The next two plot types help visualize the policy. Thus, we first need to create a policy and simulate some trajectories. So, let's take the model from Basic IV: Markov uncertainty, train it for 20 iterations, and then simulate 100 Monte Carlo realizations of the policy.","category":"page"},{"location":"tutorial/05_plotting/","page":"Basic V: plotting","title":"Basic V: plotting","text":"using SDDP, GLPK\n\nΩ = [\n    (inflow = 0.0, fuel_multiplier = 1.5),\n    (inflow = 50.0, fuel_multiplier = 1.0),\n    (inflow = 100.0, fuel_multiplier = 0.75)\n]\n\nmodel = SDDP.MarkovianPolicyGraph(\n    transition_matrices = Array{Float64, 2}[\n        [1.0]', [0.75 0.25], [0.75 0.25 ; 0.25 0.75]\n    ],\n    sense = :Min,\n    lower_bound = 0.0,\n    optimizer = GLPK.Optimizer\n) do subproblem, node\n    t, markov_state = node\n    @variable(subproblem, 0 <= volume <= 200, SDDP.State, initial_value = 200)\n    @variables(subproblem, begin\n        thermal_generation >= 0\n        hydro_generation >= 0\n        hydro_spill >= 0\n        inflow\n    end)\n    @constraints(subproblem, begin\n        volume.out == volume.in + inflow - hydro_generation - hydro_spill\n        thermal_generation + hydro_generation == 150.0\n    end)\n    probability = markov_state == 1 ? [1/6, 1/3, 1/2] : [1/2, 1/3, 1/6]\n    fuel_cost = [50.0, 100.0, 150.0]\n    SDDP.parameterize(subproblem, Ω, probability) do ω\n        JuMP.fix(inflow, ω.inflow)\n        @stageobjective(subproblem,\n            ω.fuel_multiplier * fuel_cost[t] * thermal_generation\n        )\n    end\nend\n\nSDDP.train(model, iteration_limit = 20, run_numerical_stability_report = false)\n\nsimulations = SDDP.simulate(\n    model,\n    100,\n    [:volume, :thermal_generation, :hydro_generation, :hydro_spill])\n\nprintln(\"Completed $(length(simulations)) simulations.\")","category":"page"},{"location":"tutorial/05_plotting/","page":"Basic V: plotting","title":"Basic V: plotting","text":"Great! Now we have some data in simulations to visualize.","category":"page"},{"location":"tutorial/05_plotting/#Spaghetti-plots","page":"Basic V: plotting","title":"Spaghetti plots","text":"","category":"section"},{"location":"tutorial/05_plotting/","page":"Basic V: plotting","title":"Basic V: plotting","text":"The first plotting utility we discuss is a spaghetti plot (you'll understand the name when you see the graph).","category":"page"},{"location":"tutorial/05_plotting/","page":"Basic V: plotting","title":"Basic V: plotting","text":"To create a spaghetti plot, begin by creating a new SDDP.SpaghettiPlot instance as follows:","category":"page"},{"location":"tutorial/05_plotting/","page":"Basic V: plotting","title":"Basic V: plotting","text":"plt = SDDP.SpaghettiPlot(simulations)","category":"page"},{"location":"tutorial/05_plotting/","page":"Basic V: plotting","title":"Basic V: plotting","text":"We can add plots to plt using the SDDP.add_spaghetti function.","category":"page"},{"location":"tutorial/05_plotting/","page":"Basic V: plotting","title":"Basic V: plotting","text":"SDDP.add_spaghetti(plt; title = \"Reservoir volume\") do data\n    return data[:volume].out\nend","category":"page"},{"location":"tutorial/05_plotting/","page":"Basic V: plotting","title":"Basic V: plotting","text":"You don't have just return values from the simulation, you can compute things too.","category":"page"},{"location":"tutorial/05_plotting/","page":"Basic V: plotting","title":"Basic V: plotting","text":"SDDP.add_spaghetti(\n    plt; title = \"Fuel cost\", ymin = 0, ymax = 250\n) do data\n    if data[:thermal_generation] > 0\n        return data[:stage_objective] / data[:thermal_generation]\n    else  # No thermal generation, so return 0.0.\n        return 0.0\n    end\nend","category":"page"},{"location":"tutorial/05_plotting/","page":"Basic V: plotting","title":"Basic V: plotting","text":"Note that there are many keyword arguments in addition to title. For example, we fixed the minimum and maximum values of the y-axis using ymin and ymax. See the SDDP.add_spaghetti documentation for all the arguments.","category":"page"},{"location":"tutorial/05_plotting/","page":"Basic V: plotting","title":"Basic V: plotting","text":"Having built the plot, we now need to display it using SDDP.plot.","category":"page"},{"location":"tutorial/05_plotting/","page":"Basic V: plotting","title":"Basic V: plotting","text":"SDDP.plot(plt, \"spaghetti_plot.html\")","category":"page"},{"location":"tutorial/05_plotting/","page":"Basic V: plotting","title":"Basic V: plotting","text":"This should open a webpage that looks like this one.","category":"page"},{"location":"tutorial/05_plotting/","page":"Basic V: plotting","title":"Basic V: plotting","text":"Using the mouse, you can highlight individual trajectories by hovering over them. This makes it possible to visualize a single trajectory across multiple dimensions.","category":"page"},{"location":"tutorial/05_plotting/","page":"Basic V: plotting","title":"Basic V: plotting","text":"If you click on the plot, then trajectories that are close to the mouse pointer are shown darker and those further away are shown lighter.","category":"page"},{"location":"tutorial/05_plotting/#Publication-plots","page":"Basic V: plotting","title":"Publication plots","text":"","category":"section"},{"location":"tutorial/05_plotting/","page":"Basic V: plotting","title":"Basic V: plotting","text":"Instead of the interactive Javascript plots, you can also create some publication ready plots using the SDDP.publication_plot function.","category":"page"},{"location":"tutorial/05_plotting/","page":"Basic V: plotting","title":"Basic V: plotting","text":"info: Info\nYou need to install the Plots.jl package for this to work. We used the GR backend (gr()), but any Plots.jl backend should work.","category":"page"},{"location":"tutorial/05_plotting/","page":"Basic V: plotting","title":"Basic V: plotting","text":"SDDP.publication_plot implements a plot recipe to create ribbon plots of each variable against the stages. The first argument is the vector of simulation dictionaries and the second argument is the dictionary key that you want to plot. Standard Plots.jl keyword arguments such as title and xlabel can be used to modify the look of each plot. By default, the plot displays ribbons of the 0-100, 10-90, and 25-75 percentiles. The dark, solid line in the middle is the median (i.e. 50'th percentile).","category":"page"},{"location":"tutorial/05_plotting/","page":"Basic V: plotting","title":"Basic V: plotting","text":"using Plots\nplot(\n    SDDP.publication_plot(simulations, title = \"Outgoing volume\") do data\n        return data[:volume].out\n    end,\n    SDDP.publication_plot(simulations, title = \"Thermal generation\") do data\n        return data[:thermal_generation]\n    end,\n    xlabel = \"Stage\",\n    ylims = (0, 200),\n    layout = (1, 2),\n    margin_bottom = 5,\n    size = (1000, 300)\n)","category":"page"},{"location":"tutorial/05_plotting/","page":"Basic V: plotting","title":"Basic V: plotting","text":"This should open a plot window with a plot that looks like:","category":"page"},{"location":"tutorial/05_plotting/","page":"Basic V: plotting","title":"Basic V: plotting","text":"(Image: publication plot)","category":"page"},{"location":"tutorial/05_plotting/","page":"Basic V: plotting","title":"Basic V: plotting","text":"You can save this plot as a PDF using the Plots.jl function savefig:","category":"page"},{"location":"tutorial/05_plotting/","page":"Basic V: plotting","title":"Basic V: plotting","text":"Plots.savefig(\"my_picture.pdf\")","category":"page"},{"location":"tutorial/05_plotting/#Plotting-the-value-function","page":"Basic V: plotting","title":"Plotting the value function","text":"","category":"section"},{"location":"tutorial/05_plotting/","page":"Basic V: plotting","title":"Basic V: plotting","text":"You can obtain an object representing the value function of a node using SDDP.ValueFunction.","category":"page"},{"location":"tutorial/05_plotting/","page":"Basic V: plotting","title":"Basic V: plotting","text":"V = SDDP.ValueFunction(model[(1, 1)])","category":"page"},{"location":"tutorial/05_plotting/","page":"Basic V: plotting","title":"Basic V: plotting","text":"The value function can be evaluated using SDDP.evaluate.","category":"page"},{"location":"tutorial/05_plotting/","page":"Basic V: plotting","title":"Basic V: plotting","text":"SDDP.evaluate(V; volume = 1)","category":"page"},{"location":"tutorial/05_plotting/","page":"Basic V: plotting","title":"Basic V: plotting","text":"evaluate returns the heigh of the value function, and a subgradient with respect to the convex state variables.","category":"page"},{"location":"tutorial/05_plotting/","page":"Basic V: plotting","title":"Basic V: plotting","text":"You can also plot the value function using SDDP.plot","category":"page"},{"location":"tutorial/05_plotting/","page":"Basic V: plotting","title":"Basic V: plotting","text":"SDDP.plot(V, volume = 0:200, filename = \"value_function.html\")","category":"page"},{"location":"tutorial/05_plotting/","page":"Basic V: plotting","title":"Basic V: plotting","text":"This should open a webpage that looks like this one.","category":"page"},{"location":"tutorial/05_plotting/#Convergence-dashboard","page":"Basic V: plotting","title":"Convergence dashboard","text":"","category":"section"},{"location":"tutorial/05_plotting/","page":"Basic V: plotting","title":"Basic V: plotting","text":"If the text-based logging isn't to your liking, you can open a visualization of the training by passing  dashboard = true to SDDP.train.","category":"page"},{"location":"tutorial/05_plotting/","page":"Basic V: plotting","title":"Basic V: plotting","text":"SDDP.train(model; dashboard = true)","category":"page"},{"location":"tutorial/05_plotting/","page":"Basic V: plotting","title":"Basic V: plotting","text":"By default, dashboard = false because there is an initial overhead associated with opening and preparing the plot.","category":"page"},{"location":"tutorial/05_plotting/","page":"Basic V: plotting","title":"Basic V: plotting","text":"warning: Warning\nThe dashboard is experimental. There are known bugs associated with it, e.g., SDDP.jl#226.","category":"page"},{"location":"tutorial/05_plotting/","page":"Basic V: plotting","title":"Basic V: plotting","text":"This concludes our fifth tutorial for SDDP.jl. In our next tutorial, Basic VI: words of warning we discuss some of the issues that you should be aware of when creating your own models.","category":"page"},{"location":"tutorial/05_plotting/","page":"Basic V: plotting","title":"Basic V: plotting","text":"","category":"page"},{"location":"tutorial/05_plotting/","page":"Basic V: plotting","title":"Basic V: plotting","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorial/12_belief_states/","page":"Advanced II: belief states","title":"Advanced II: belief states","text":"EditURL = \"https://github.com/odow/SDDP.jl/blob/master/docs/src/tutorial/12_belief_states.jl\"","category":"page"},{"location":"tutorial/12_belief_states/#Advanced-II:-belief-states","page":"Advanced II: belief states","title":"Advanced II: belief states","text":"","category":"section"},{"location":"tutorial/12_belief_states/","page":"Advanced II: belief states","title":"Advanced II: belief states","text":"SDDP.jl includes an implementation of the algorithm described in Dowson, O., Morton, D.P., & Pagnoncelli, B. (2019). Partially observable multistage stochastic programming. [link]","category":"page"},{"location":"tutorial/12_belief_states/","page":"Advanced II: belief states","title":"Advanced II: belief states","text":"Proper documentation will be forthcoming.","category":"page"},{"location":"tutorial/12_belief_states/","page":"Advanced II: belief states","title":"Advanced II: belief states","text":"In the mean-time, here is most of what you need to know.","category":"page"},{"location":"tutorial/12_belief_states/#Defining-the-ambiguity-partition","page":"Advanced II: belief states","title":"Defining the ambiguity partition","text":"","category":"section"},{"location":"tutorial/12_belief_states/","page":"Advanced II: belief states","title":"Advanced II: belief states","text":"Given a SDDP.Graph object (see Create a general policy graph for details), we can define the ambiguity partition using SDDP.add_ambiguity_set.","category":"page"},{"location":"tutorial/12_belief_states/","page":"Advanced II: belief states","title":"Advanced II: belief states","text":"For example, first we create a Markovian graph:","category":"page"},{"location":"tutorial/12_belief_states/","page":"Advanced II: belief states","title":"Advanced II: belief states","text":"using SDDP\n\nG = SDDP.MarkovianGraph([[0.5 0.5], [0.2 0.8; 0.8 0.2]])","category":"page"},{"location":"tutorial/12_belief_states/","page":"Advanced II: belief states","title":"Advanced II: belief states","text":"Then we add  an ambiguity set over the nodes in the first stage:","category":"page"},{"location":"tutorial/12_belief_states/","page":"Advanced II: belief states","title":"Advanced II: belief states","text":"SDDP.add_ambiguity_set(G, [(1, 1), (1, 2)])","category":"page"},{"location":"tutorial/12_belief_states/","page":"Advanced II: belief states","title":"Advanced II: belief states","text":"Then we add  an ambiguity set over the nodes in the second stage:","category":"page"},{"location":"tutorial/12_belief_states/","page":"Advanced II: belief states","title":"Advanced II: belief states","text":"SDDP.add_ambiguity_set(G, [(2, 1), (2, 2)])","category":"page"},{"location":"tutorial/12_belief_states/","page":"Advanced II: belief states","title":"Advanced II: belief states","text":"This results in the graph:","category":"page"},{"location":"tutorial/12_belief_states/","page":"Advanced II: belief states","title":"Advanced II: belief states","text":"G","category":"page"},{"location":"tutorial/12_belief_states/","page":"Advanced II: belief states","title":"Advanced II: belief states","text":"","category":"page"},{"location":"tutorial/12_belief_states/","page":"Advanced II: belief states","title":"Advanced II: belief states","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorial/22_pedagogical_sddp/","page":"Expert I: Pedagogical SDDP","title":"Expert I: Pedagogical SDDP","text":"EditURL = \"https://github.com/odow/SDDP.jl/blob/master/docs/src/tutorial/22_pedagogical_sddp.jl\"","category":"page"},{"location":"tutorial/22_pedagogical_sddp/#Expert-I:-Pedagogical-SDDP","page":"Expert I: Pedagogical SDDP","title":"Expert I: Pedagogical SDDP","text":"","category":"section"},{"location":"tutorial/22_pedagogical_sddp/","page":"Expert I: Pedagogical SDDP","title":"Expert I: Pedagogical SDDP","text":"In this tutorial we walk through a simplified implementation of stochastic dual dynamic programming to explain the key concepts.","category":"page"},{"location":"tutorial/22_pedagogical_sddp/","page":"Expert I: Pedagogical SDDP","title":"Expert I: Pedagogical SDDP","text":"note: Note\nIf you haven't already, go read Basic I: first steps, since it introduces much necessary background theory, and Basic II: adding uncertainty, since it defines the same example we will solve in our implementation.","category":"page"},{"location":"tutorial/22_pedagogical_sddp/","page":"Expert I: Pedagogical SDDP","title":"Expert I: Pedagogical SDDP","text":"This tutorial uses the following packages. For clarity, we call import PackageName so that we must prefix PackageName. to all functions and structs provided by that package. Everything not prefixed is either part of base Julia, or we wrote it.","category":"page"},{"location":"tutorial/22_pedagogical_sddp/","page":"Expert I: Pedagogical SDDP","title":"Expert I: Pedagogical SDDP","text":"import ForwardDiff\nimport GLPK\nimport JuMP\nimport Statistics","category":"page"},{"location":"tutorial/22_pedagogical_sddp/#Theory","page":"Expert I: Pedagogical SDDP","title":"Theory","text":"","category":"section"},{"location":"tutorial/22_pedagogical_sddp/#Preliminaries:-Kelley's-cutting-plane-algorithm","page":"Expert I: Pedagogical SDDP","title":"Preliminaries: Kelley's cutting plane algorithm","text":"","category":"section"},{"location":"tutorial/22_pedagogical_sddp/","page":"Expert I: Pedagogical SDDP","title":"Expert I: Pedagogical SDDP","text":"Kelley's cutting plane algorithm is an iterative method for minimizing convex functions. Given a convex function f(x), Kelley's constructs an under-approximation of the function at the minimum by a set of first-order Taylor series approximations (called cuts) constructed at a set of K points k = 1ldotsK:","category":"page"},{"location":"tutorial/22_pedagogical_sddp/","page":"Expert I: Pedagogical SDDP","title":"Expert I: Pedagogical SDDP","text":"beginaligned\nf^K = minlimits_theta x   theta\n theta ge f(x_k) + fracdfdxleft(x_kright) cdot (x - x_k)quad k=1ldotsK\n theta ge M\nendaligned","category":"page"},{"location":"tutorial/22_pedagogical_sddp/","page":"Expert I: Pedagogical SDDP","title":"Expert I: Pedagogical SDDP","text":"where M is a sufficiently large negative number that is a lower bound for f over the domain of x.","category":"page"},{"location":"tutorial/22_pedagogical_sddp/","page":"Expert I: Pedagogical SDDP","title":"Expert I: Pedagogical SDDP","text":"As more cuts are added:","category":"page"},{"location":"tutorial/22_pedagogical_sddp/","page":"Expert I: Pedagogical SDDP","title":"Expert I: Pedagogical SDDP","text":"lim_K rightarrow infty f^K = minlimits_x f(x)","category":"page"},{"location":"tutorial/22_pedagogical_sddp/#Bounds","page":"Expert I: Pedagogical SDDP","title":"Bounds","text":"","category":"section"},{"location":"tutorial/22_pedagogical_sddp/","page":"Expert I: Pedagogical SDDP","title":"Expert I: Pedagogical SDDP","text":"By convexity, f^K le f(x) for all x. Thus, if x^* is a minimizer of f, then at any point in time we can construct a lower bound for f(x^*) by solving f^K.","category":"page"},{"location":"tutorial/22_pedagogical_sddp/","page":"Expert I: Pedagogical SDDP","title":"Expert I: Pedagogical SDDP","text":"Moreover, since any feasible point is an upper bound, we can use the primal solution x^K returned by solving f^K to evaluate f(x_K) to generate an upper bound.","category":"page"},{"location":"tutorial/22_pedagogical_sddp/","page":"Expert I: Pedagogical SDDP","title":"Expert I: Pedagogical SDDP","text":"Therefore, f(x^*) in f^K f(x_K).","category":"page"},{"location":"tutorial/22_pedagogical_sddp/#Implementation","page":"Expert I: Pedagogical SDDP","title":"Implementation","text":"","category":"section"},{"location":"tutorial/22_pedagogical_sddp/","page":"Expert I: Pedagogical SDDP","title":"Expert I: Pedagogical SDDP","text":"Here is pseudo-code fo the algorithm:","category":"page"},{"location":"tutorial/22_pedagogical_sddp/","page":"Expert I: Pedagogical SDDP","title":"Expert I: Pedagogical SDDP","text":"Take as input a function f and a iteration limit K_max. Set K = 0, and initialize f^K\nSolve f^K to obtain a candidate solution x_K+1.\nAdd a cut theta ge f(x_K+1) + fracdfdxleft(x_K+1right)^top (x - x_K+1) to form f^K+1.\nIncrement K\nIf K = K_max STOP, otherwise, go to step 2.","category":"page"},{"location":"tutorial/22_pedagogical_sddp/","page":"Expert I: Pedagogical SDDP","title":"Expert I: Pedagogical SDDP","text":"And here's a complete implementation:","category":"page"},{"location":"tutorial/22_pedagogical_sddp/","page":"Expert I: Pedagogical SDDP","title":"Expert I: Pedagogical SDDP","text":"function kelleys_cutting_plane(\n    # The function to be minimized.\n    f::Function,\n    # The gradient of `f`. By default, we use automatic differentiation to\n    # compute the gradient of f so the user doesn't have to!\n    dfdx::Function = x -> ForwardDiff.gradient(f, x);\n    # The number of arguments to `f`.\n    input_dimension::Int,\n    # A lower bound for the function `f` over its domain.\n    lower_bound::Float64,\n    # The number of iterations to run Kelley's algorithm for before stopping.\n    iteration_limit::Int,\n)\n    # Step (1):\n    K = 0\n    model = JuMP.Model(GLPK.Optimizer)\n    JuMP.@variable(model, θ >= lower_bound)\n    JuMP.@variable(model, x[1:input_dimension])\n    JuMP.@objective(model, Min, θ)\n    while true\n        # Step (2)\n        JuMP.optimize!(model)\n        x_k = JuMP.value.(x)\n        # Step (3):\n        c = JuMP.@constraint(model, θ >= f(x_k) + dfdx(x_k)' * (x .- x_k))\n        # Step (4):\n        K = K + 1\n        # Step (5):\n        if K == iteration_limit\n            break\n        end\n    end\n    θ_K, x_K = JuMP.value(θ), JuMP.value.(x)\n    println(\"Found solution:\")\n    println(\"  x_K   = \", x_K)\n    println(\"  f(x*) ∈ [\", θ_K, \", \", f(x_K), \"]\")\n    return\nend","category":"page"},{"location":"tutorial/22_pedagogical_sddp/","page":"Expert I: Pedagogical SDDP","title":"Expert I: Pedagogical SDDP","text":"Let's run our algorithm to see what happens:","category":"page"},{"location":"tutorial/22_pedagogical_sddp/","page":"Expert I: Pedagogical SDDP","title":"Expert I: Pedagogical SDDP","text":"kelleys_cutting_plane(\n    input_dimension = 2,\n    lower_bound = 0.0,\n    iteration_limit = 20,\n) do x\n    return (x[1] - 1)^2 + (x[2] + 2)^2\nend","category":"page"},{"location":"tutorial/22_pedagogical_sddp/#Approximating-the-cost-to-go-term","page":"Expert I: Pedagogical SDDP","title":"Approximating the cost-to-go term","text":"","category":"section"},{"location":"tutorial/22_pedagogical_sddp/","page":"Expert I: Pedagogical SDDP","title":"Expert I: Pedagogical SDDP","text":"In Basic I: first steps, we discussed how you could formulate an optimal policy to a multistage stochastic program using the dynamic programming recursion:","category":"page"},{"location":"tutorial/22_pedagogical_sddp/","page":"Expert I: Pedagogical SDDP","title":"Expert I: Pedagogical SDDP","text":"beginaligned\nV_i(x omega) = minlimits_barx x^prime u   C_i(barx u omega) + mathbbE_j in i^+ varphi in Omega_jV_j(x^prime varphi)\n x^prime = T_i(barx u omega) \n u in U_i(barx omega) \n barx = x\nendaligned","category":"page"},{"location":"tutorial/22_pedagogical_sddp/","page":"Expert I: Pedagogical SDDP","title":"Expert I: Pedagogical SDDP","text":"where our decision rule, pi_i(x omega), solves this optimization problem and returns a u^* corresponding to an optimal solution. Moreover, we alluded to the fact that the cost-to-go term (the nasty recursive expectation) makes this problem intractable to solve.","category":"page"},{"location":"tutorial/22_pedagogical_sddp/","page":"Expert I: Pedagogical SDDP","title":"Expert I: Pedagogical SDDP","text":"However, if, excluding the cost-to-go term, V_i(x omega) can be formulated as a linear program (this also works for convex programs, but the math is more involved), then we can make some progress.","category":"page"},{"location":"tutorial/22_pedagogical_sddp/","page":"Expert I: Pedagogical SDDP","title":"Expert I: Pedagogical SDDP","text":"First, notice that x only appears as a right-hand side term of V_i. Therefore, V_i(x cdot) is convex with respect to x for fixed omega. Moreover, the reduced cost of the decision variable barx is a subgradient of the function V_i with respect to x! (This is one reason why we add the barx and the fishing constraint barx = x.)","category":"page"},{"location":"tutorial/22_pedagogical_sddp/","page":"Expert I: Pedagogical SDDP","title":"Expert I: Pedagogical SDDP","text":"Second, a convex combination of convex functions is also convex, so the cost-to-go term is a convex function of x^prime.","category":"page"},{"location":"tutorial/22_pedagogical_sddp/","page":"Expert I: Pedagogical SDDP","title":"Expert I: Pedagogical SDDP","text":"Stochastic dual dynamic programming converts this problem into a tractable form by applying Kelley's cutting plane algorithm to the cost-to-go term:","category":"page"},{"location":"tutorial/22_pedagogical_sddp/","page":"Expert I: Pedagogical SDDP","title":"Expert I: Pedagogical SDDP","text":"beginaligned\nV_i^K(x omega) = minlimits_barx x^prime u   C_i(barx u omega) + theta\n x^prime = T_i(barx u omega) \n u in U_i(barx omega) \n barx = x \n theta ge mathbbE_j in i^+ varphi in Omega_jleftV_j^k(x^prime_k varphi) + fracdV_j^kdx^primeleft(x^prime_k varphiright)^top (x^prime - x^prime_k)rightquad k=1ldotsK \n theta ge M\nendaligned","category":"page"},{"location":"tutorial/22_pedagogical_sddp/","page":"Expert I: Pedagogical SDDP","title":"Expert I: Pedagogical SDDP","text":"All we need now is a way of generating these cutting planes in an iterative manner.","category":"page"},{"location":"tutorial/22_pedagogical_sddp/#The-forward-pass","page":"Expert I: Pedagogical SDDP","title":"The forward pass","text":"","category":"section"},{"location":"tutorial/22_pedagogical_sddp/#The-backward-pass","page":"Expert I: Pedagogical SDDP","title":"The backward pass","text":"","category":"section"},{"location":"tutorial/22_pedagogical_sddp/#Implementation-2","page":"Expert I: Pedagogical SDDP","title":"Implementation","text":"","category":"section"},{"location":"tutorial/22_pedagogical_sddp/","page":"Expert I: Pedagogical SDDP","title":"Expert I: Pedagogical SDDP","text":"For this implementation of SDDP, we're going to try and keep things as simple as possible. This is very much a \"vanilla\" version of SDDP; it doesn't have (m)any fancy computational tricks that you need to code a performant or stable version that will work on realistic instances.","category":"page"},{"location":"tutorial/22_pedagogical_sddp/","page":"Expert I: Pedagogical SDDP","title":"Expert I: Pedagogical SDDP","text":"In the interests of brevity, we will also include minimal error checking. Think about all the different ways you could break this code!","category":"page"},{"location":"tutorial/22_pedagogical_sddp/#Structs","page":"Expert I: Pedagogical SDDP","title":"Structs","text":"","category":"section"},{"location":"tutorial/22_pedagogical_sddp/","page":"Expert I: Pedagogical SDDP","title":"Expert I: Pedagogical SDDP","text":"The first struct we are going to use is a State struct that will wrap an incoming and outgoing state variable.","category":"page"},{"location":"tutorial/22_pedagogical_sddp/","page":"Expert I: Pedagogical SDDP","title":"Expert I: Pedagogical SDDP","text":"struct State\n    in::JuMP.VariableRef\n    out::JuMP.VariableRef\nend","category":"page"},{"location":"tutorial/22_pedagogical_sddp/","page":"Expert I: Pedagogical SDDP","title":"Expert I: Pedagogical SDDP","text":"Next, we need a struct to wrap all of the uncertainty within a node.","category":"page"},{"location":"tutorial/22_pedagogical_sddp/","page":"Expert I: Pedagogical SDDP","title":"Expert I: Pedagogical SDDP","text":"struct Uncertainty\n    parameterize::Function\n    Ω::Vector{Any}\n    P::Vector{Float64}\nend","category":"page"},{"location":"tutorial/22_pedagogical_sddp/","page":"Expert I: Pedagogical SDDP","title":"Expert I: Pedagogical SDDP","text":"parameterize is a function, which takes a realization of the random variable omegainOmega and updates the subproblem accordingly. The finite discrete random variable is defined by the vectors Ω and P, so that the random variable takes the value Ω[i] with probability P[i]. As such, P should sum to 1. (We don't check this here, but we should; we do in SDDP.jl.)","category":"page"},{"location":"tutorial/22_pedagogical_sddp/","page":"Expert I: Pedagogical SDDP","title":"Expert I: Pedagogical SDDP","text":"It's also going to be useful to have a function that samples a realization of the random variable defined by Ω and P:","category":"page"},{"location":"tutorial/22_pedagogical_sddp/","page":"Expert I: Pedagogical SDDP","title":"Expert I: Pedagogical SDDP","text":"function sample_uncertainty(uncertainty::Uncertainty)\n    r = rand()\n    for (p, ω) in zip(uncertainty.P, uncertainty.Ω)\n        if r <= p\n            return ω\n        end\n        r -= p\n    end\n    error(\"We should never get here because P should sum to 1.0.\")\nend","category":"page"},{"location":"tutorial/22_pedagogical_sddp/","page":"Expert I: Pedagogical SDDP","title":"Expert I: Pedagogical SDDP","text":"You should be able to work out what is going on. rand() samples a uniform random variable in [0, 1).","category":"page"},{"location":"tutorial/22_pedagogical_sddp/","page":"Expert I: Pedagogical SDDP","title":"Expert I: Pedagogical SDDP","text":"Now we have two building blocks, we can declare the structure of each node.","category":"page"},{"location":"tutorial/22_pedagogical_sddp/","page":"Expert I: Pedagogical SDDP","title":"Expert I: Pedagogical SDDP","text":"struct Node\n    subproblem::JuMP.Model\n    states::Dict{Symbol, State}\n    uncertainty::Uncertainty\n    cost_to_go::JuMP.VariableRef\nend","category":"page"},{"location":"tutorial/22_pedagogical_sddp/","page":"Expert I: Pedagogical SDDP","title":"Expert I: Pedagogical SDDP","text":"subproblem is going to be the JuMP model that we build at each node. states is a dictionary that maps a symbolic name of a state variable to a State object wrapping the incoming and outgoing state variables in subproblem. uncertainty is an Uncertainty object described above, and cost_to_go is a JuMP variable that approximates the cost-to-go term.","category":"page"},{"location":"tutorial/22_pedagogical_sddp/","page":"Expert I: Pedagogical SDDP","title":"Expert I: Pedagogical SDDP","text":"Finally, out simplified policy graph is just a vector of nodes.","category":"page"},{"location":"tutorial/22_pedagogical_sddp/","page":"Expert I: Pedagogical SDDP","title":"Expert I: Pedagogical SDDP","text":"struct LinearPolicyGraph\n    nodes::Vector{Node}\nend","category":"page"},{"location":"tutorial/22_pedagogical_sddp/","page":"Expert I: Pedagogical SDDP","title":"Expert I: Pedagogical SDDP","text":"We also define a nice show method so that we don't accidentally print a large amount of information to the screen.","category":"page"},{"location":"tutorial/22_pedagogical_sddp/","page":"Expert I: Pedagogical SDDP","title":"Expert I: Pedagogical SDDP","text":"function Base.show(io::IO, model::LinearPolicyGraph)\n    return print(io, \"A policy graph with $(length(model.nodes)) nodes\")\nend","category":"page"},{"location":"tutorial/22_pedagogical_sddp/#Interface-functions","page":"Expert I: Pedagogical SDDP","title":"Interface functions","text":"","category":"section"},{"location":"tutorial/22_pedagogical_sddp/","page":"Expert I: Pedagogical SDDP","title":"Expert I: Pedagogical SDDP","text":"Now we have some basic types, let's implment some functions so that the user can create a model.","category":"page"},{"location":"tutorial/22_pedagogical_sddp/","page":"Expert I: Pedagogical SDDP","title":"Expert I: Pedagogical SDDP","text":"First, we need an exmaple of a function that the user will provide. Like SDDP.jl, this takes an empty subproblem, and a node index, in this case t::Int. You could change this function to change the model, or define a new one later in the code.","category":"page"},{"location":"tutorial/22_pedagogical_sddp/","page":"Expert I: Pedagogical SDDP","title":"Expert I: Pedagogical SDDP","text":"function subproblem_builder(subproblem::JuMP.Model, t::Int)\n    # Define the state variables. Note how we fix the incoming state to the\n    # initial state variable regardless of `t`! This isn't strictly necessary;\n    # it only matters that we do it for the first node.\n    JuMP.@variable(subproblem, volume_in == 200)\n    JuMP.@variable(subproblem, 0 <= volume_out <= 200)\n    states = Dict(:volume => State(volume_in, volume_out))\n    # Define the control variables.\n    JuMP.@variables(subproblem, begin\n        thermal_generation >= 0\n        hydro_generation   >= 0\n        hydro_spill        >= 0\n        inflow\n    end)\n    # Define the constraints\n    JuMP.@constraints(subproblem, begin\n        volume_out == volume_in + inflow - hydro_generation - hydro_spill\n        demand_constraint, thermal_generation + hydro_generation == 150.0\n    end)\n    # Define the objective for each stage `t`. Note that we can use `t` as an\n    # index for t = 1, 2, 3.\n    fuel_cost = [50.0, 100.0, 150.0]\n    JuMP.@objective(subproblem, Min, fuel_cost[t] * thermal_generation)\n    # Finally, we define the uncertainty object. Because this is a simplified\n    # implementation of SDDP, we shall politely ask the user to only modify the\n    # constraints, and not the objective function! (Not that it changes the\n    # algorithm, we just have to add more information to keep track of things.)\n    uncertainty = Uncertainty([0.0, 50.0, 100.0], [1 / 3, 1 / 3, 1 / 3]) do ω\n        JuMP.fix(inflow, ω)\n    end\n    return states, uncertainty\nend","category":"page"},{"location":"tutorial/22_pedagogical_sddp/","page":"Expert I: Pedagogical SDDP","title":"Expert I: Pedagogical SDDP","text":"If you've read Basic II: adding uncertainty, this example should be familiar. You can probably see how some of the SDDP.jl functionality like @stageobjective and SDDP.parameterize help smooth some of the usability issues like needing to construct both the incoming and outgoing state variables, or needing to explicitly return states, uncertainty.","category":"page"},{"location":"tutorial/22_pedagogical_sddp/","page":"Expert I: Pedagogical SDDP","title":"Expert I: Pedagogical SDDP","text":"The next function we need to define is the analog of SDDP.LinearPolicyGraph. It should be pretty readable.","category":"page"},{"location":"tutorial/22_pedagogical_sddp/","page":"Expert I: Pedagogical SDDP","title":"Expert I: Pedagogical SDDP","text":"function LinearPolicyGraph(\n    subproblem_builder::Function;\n    stages::Int,\n    lower_bound::Float64,\n    optimizer,\n)\n    nodes = Node[]\n    for t = 1:stages\n        # Create a model.\n        model = JuMP.Model(optimizer)\n        # Use the provided function to build out each subproblem. The user's\n        # function returns a dictionary mapping `Symbol`s to `State` objects,\n        # and an `Uncertainty` object.\n        states, uncertainty = subproblem_builder(model, t)\n        # Now add the cost-to-go terms:\n        JuMP.@variable(model, cost_to_go >= lower_bound)\n        obj = JuMP.objective_function(model)\n        JuMP.@objective(model, Min, obj + cost_to_go)\n        # In the final stage, the cost-to-go is 0.0.\n        if t == stages\n            JuMP.fix(cost_to_go, 0.0; force = true)\n        end\n        push!(nodes, Node(model, states, uncertainty, cost_to_go))\n    end\n    return LinearPolicyGraph(nodes)\nend","category":"page"},{"location":"tutorial/22_pedagogical_sddp/#The-forward-pass-2","page":"Expert I: Pedagogical SDDP","title":"The forward pass","text":"","category":"section"},{"location":"tutorial/22_pedagogical_sddp/","page":"Expert I: Pedagogical SDDP","title":"Expert I: Pedagogical SDDP","text":"Now we're ready to code the forward pass. It takes a ::LinearPolicyGraph, and returns a tuple of two things: a vector of the outgoing state variables visited, and a Float64 of the cumulative stage costs that were incurred along the forward pass.","category":"page"},{"location":"tutorial/22_pedagogical_sddp/","page":"Expert I: Pedagogical SDDP","title":"Expert I: Pedagogical SDDP","text":"function forward_pass(model::LinearPolicyGraph, io::IO = stdout)\n    println(io, \"| Forward Pass\")\n    # First, get the value of the state at the root node (e.g., x_R).\n    incoming_state = Dict(\n        k => JuMP.fix_value(v.in) for (k, v) in model.nodes[1].states\n    )\n    # `simulation_cost` is an accumlator that is going to sum the stage-costs\n    # incurred over the forward pass.\n    simulation_cost = 0.0\n    # We also need to record the outgoing state variables so we can pass them\n    # to the backward pass.\n    outgoing_states = Dict{Symbol, Float64}[]\n    # Now's the meat of the forward pass: loop through each of the nodes\n    for (t, node) in enumerate(model.nodes)\n        println(io, \"| | Visiting node $(t)\")\n        # Sample the uncertainty:\n        ω = sample_uncertainty(node.uncertainty)\n        println(io, \"| |  ω = \", ω)\n        # Before parameterizing the subproblem using the user-provided\n        # function:\n        node.uncertainty.parameterize(ω)\n        println(io, \"| |  x = \", incoming_state)\n        # Update the incoming state variable:\n        for (k, v) in incoming_state\n            JuMP.fix(node.states[k].in, v; force = true)\n        end\n        # Now solve the subproblem and check we found an optimal solution:\n        JuMP.optimize!(node.subproblem)\n        if JuMP.termination_status(node.subproblem) != JuMP.MOI.OPTIMAL\n            error(\"Something went terribly wrong!\")\n        end\n        # Compute the outgoing state variables, and save them in\n        # `outgoing_states`:\n        outgoing_state = Dict(k => JuMP.value(v.out) for (k, v) in node.states)\n        push!(outgoing_states, outgoing_state)\n        println(io, \"| |  x′ = \", outgoing_state)\n        # We also need to compute the stage cost to add to our\n        # `simulation_cost` accumulator:\n        stage_cost = JuMP.objective_value(node.subproblem) - JuMP.value(node.cost_to_go)\n        simulation_cost += stage_cost\n        println(io, \"| |  C(x, u, ω) = \", stage_cost)\n        # As a final step, set the outgoing state of stage t and the incoming\n        # state of stage t + 1:\n        incoming_state = outgoing_state\n    end\n    return outgoing_states, simulation_cost\nend","category":"page"},{"location":"tutorial/22_pedagogical_sddp/#The-backward-pass-2","page":"Expert I: Pedagogical SDDP","title":"The backward pass","text":"","category":"section"},{"location":"tutorial/22_pedagogical_sddp/","page":"Expert I: Pedagogical SDDP","title":"Expert I: Pedagogical SDDP","text":"We're now ready to code the backward pass. This is going to take a ::LinearPolicyGraph object, and a vector of outgoing states from the forward pass. It returns a Float64 that is a valid lower bound for the objective of the multistage stochastic program.","category":"page"},{"location":"tutorial/22_pedagogical_sddp/","page":"Expert I: Pedagogical SDDP","title":"Expert I: Pedagogical SDDP","text":"function backward_pass(\n    model::LinearPolicyGraph,\n    outgoing_states::Vector{Dict{Symbol, Float64}},\n)\n    println(\"| Backward pass\")\n    # For the backward pass, we walk back up the nodes, from the final\n    # node to the second (we will solve the first node after this loop).\n    for t = length(outgoing_states):-1:2\n        println(\"| | Visiting node $(t)\")\n        # At each step in the backward pass, we are going to solve problems in\n        # stage t, but add cuts to stage t - 1. Thus, we need:\n        node_t = model.nodes[t]\n        node_t1 = model.nodes[t - 1]\n        # First, fix the incoming state variables of stage t to the value of\n        # the outgoing state variables in stage t - 1.\n        for (k, v) in outgoing_states[t - 1]\n            JuMP.fix(node_t.states[k].in, v; force = true)\n        end\n        # Then, create an empty affine expression that we will use to build\n        # up the cut expression.\n        cut_expression = JuMP.AffExpr(0.0)\n        # Now for each possible realization of the uncertainty, solve the\n        # stage t subproblem, and add `p * [y + λᵀ(x - x_k)]` to the cut\n        # expression. (See the Theory section above is this isn't obvious why.)\n        for (p, ω) in zip(node_t.uncertainty.P, node_t.uncertainty.Ω)\n            println(\"| | | Solving ω = \", ω)\n            node_t.uncertainty.parameterize(ω)\n            JuMP.optimize!(node_t.subproblem)\n            y = JuMP.objective_value(node_t.subproblem)\n            println(\"| | |  y = \", y)\n            λ = Dict(k => JuMP.reduced_cost(v.in) for (k, v) in node_t.states)\n            println(\"| | |  λ = \", λ)\n            cut_expression += p * JuMP.@expression(\n                node_t1.subproblem,\n                y + sum(\n                    λ[k] * (x.out - outgoing_states[t - 1][k])\n                    for (k, x) in node_t1.states\n                ),\n            )\n        end\n        # And then refine the cost-to-go variable by adding a cut that is the\n        # expectation of the cuts computed in the step above.\n        c = JuMP.@constraint(\n            node_t1.subproblem, node_t1.cost_to_go >= cut_expression\n        )\n        println(\"| | | Adding cut : \", c)\n    end\n    # Finally, compute a lower bound for the problem by evaluating the\n    # first-stage subproblem.\n    first_node = model.nodes[1]\n    lower_bound = 0.0\n    for (p, ω) in zip(first_node.uncertainty.P, first_node.uncertainty.Ω)\n        first_node.uncertainty.parameterize(ω)\n        JuMP.optimize!(first_node.subproblem)\n        lower_bound += p * JuMP.objective_value(first_node.subproblem)\n    end\n    return lower_bound\nend","category":"page"},{"location":"tutorial/22_pedagogical_sddp/","page":"Expert I: Pedagogical SDDP","title":"Expert I: Pedagogical SDDP","text":"Thirdly, we need a function to simulate the policy. This is going be very simple. It doesn't have an bells and whistles like being able to record the control variables.","category":"page"},{"location":"tutorial/22_pedagogical_sddp/","page":"Expert I: Pedagogical SDDP","title":"Expert I: Pedagogical SDDP","text":"function simulate(model::LinearPolicyGraph; replications::Int)\n    # Pipe the output to `devnull` so we don't print too much!\n    simulations = [forward_pass(model, devnull) for _ = 1:replications]\n    z = [s[2] for s in simulations]\n    μ  = Statistics.mean(z)\n    tσ = 1.96 * Statistics.std(z) / sqrt(replications)\n    println(\"Upper bound = $(μ) ± $(tσ)\")\n    return simulations\nend","category":"page"},{"location":"tutorial/22_pedagogical_sddp/","page":"Expert I: Pedagogical SDDP","title":"Expert I: Pedagogical SDDP","text":"Finally, the train loop of SDDP just applies the forward and backward passes iteratively, followed by a final simulation to compute the upper bound confidence interval.","category":"page"},{"location":"tutorial/22_pedagogical_sddp/","page":"Expert I: Pedagogical SDDP","title":"Expert I: Pedagogical SDDP","text":"function train(\n    model::LinearPolicyGraph;\n    iteration_limit::Int,\n    replications::Int,\n)\n    for i = 1:iteration_limit\n        println(\"Starting iteration $(i)\")\n        outgoing_states, simulation = forward_pass(model)\n        lower_bound = backward_pass(model, outgoing_states)\n        println(\"| Finished iteration\")\n        println(\"| | simulation = \", simulation)\n        println(\"| | lower_bound = \", lower_bound)\n    end\n    simulate(model; replications = replications)\n    return\nend","category":"page"},{"location":"tutorial/22_pedagogical_sddp/#Example","page":"Expert I: Pedagogical SDDP","title":"Example","text":"","category":"section"},{"location":"tutorial/22_pedagogical_sddp/","page":"Expert I: Pedagogical SDDP","title":"Expert I: Pedagogical SDDP","text":"First, create the model using the subproblem_builder function we defined earlier:","category":"page"},{"location":"tutorial/22_pedagogical_sddp/","page":"Expert I: Pedagogical SDDP","title":"Expert I: Pedagogical SDDP","text":"model = LinearPolicyGraph(\n    subproblem_builder;\n    stages = 3,\n    lower_bound = 0.0,\n    optimizer = GLPK.Optimizer,\n)","category":"page"},{"location":"tutorial/22_pedagogical_sddp/","page":"Expert I: Pedagogical SDDP","title":"Expert I: Pedagogical SDDP","text":"Then, train a policy:","category":"page"},{"location":"tutorial/22_pedagogical_sddp/","page":"Expert I: Pedagogical SDDP","title":"Expert I: Pedagogical SDDP","text":"train(model; iteration_limit = 3, replications = 100)","category":"page"},{"location":"tutorial/22_pedagogical_sddp/","page":"Expert I: Pedagogical SDDP","title":"Expert I: Pedagogical SDDP","text":"Success! We solved a multistage stochastic program using stochastic dual dynamic programming.","category":"page"},{"location":"tutorial/22_pedagogical_sddp/","page":"Expert I: Pedagogical SDDP","title":"Expert I: Pedagogical SDDP","text":"","category":"page"},{"location":"tutorial/22_pedagogical_sddp/","page":"Expert I: Pedagogical SDDP","title":"Expert I: Pedagogical SDDP","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = SDDP","category":"page"},{"location":"#SDDP.jl","page":"Home","title":"SDDP.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SDDP.jl is a package for solving large multistage convex stochastic programming problems using stochastic dual dynamic programming. In this manual, we're going to assume a reasonable amount of background knowledge about stochastic optimization, the SDDP algorithm, Julia, and JuMP.","category":"page"},{"location":"","page":"Home","title":"Home","text":"tip: Tip\nIf you haven't used JuMP before, we recommend that you read the JuMP documentation and try building and solving JuMP models before trying SDDP.jl.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You can install SDDP.jl as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ] add SDDP","category":"page"},{"location":"#Tutorials","page":"Home","title":"Tutorials","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Once you've got SDDP.jl installed, you should read some tutorials, beginning with Basic I: first steps.","category":"page"},{"location":"#How-to-guides","page":"Home","title":"How-to guides","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you just want help on a specific topic, check out one of the how-to guides. A good one to get started on is Debug a model.","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SDDP.jl also contains a number of examples. A good one to get started on is the Hydro-thermal scheduling problem. In particular, it shows how to solve an infinite horizon problem.","category":"page"},{"location":"","page":"Home","title":"Home","text":"There is also a whole folder of coded examples in the examples directory of the Github page.","category":"page"},{"location":"#API-Reference","page":"Home","title":"API Reference","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you just want help on a specific function, see the API Reference page.","category":"page"},{"location":"#Citing-SDDP.jl","page":"Home","title":"Citing SDDP.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use SDDP.jl, we ask that you please cite the following:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@article{dowson_sddp.jl,\n\ttitle = {{SDDP}.jl: a {Julia} package for stochastic dual dynamic programming},\n\tjournal = {INFORMS Journal on Computing},\n\tauthor = {Dowson, O. and Kapelevich, L.},\n\tdoi = {https://doi.org/10.1287/ijoc.2020.0987},\n\tnote = {Articles in Advance},\n\tyear = {2020}\n}","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here is an earlier preprint.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you use the infinite horizon functionality, we ask that you please cite the following:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@article{dowson_policy_graph,\n\ttitle = {The policy graph decomposition of multistage stochastic\n      optimization problems},\n\tdoi = {https://doi.org/10.1002/net.21932},\n\tjournal = {Networks},\n\tauthor = {Dowson, O.},\n\tvolume = {76},\n\tissue = {1},\n\tpages = {3-23},\n\tyear = {2020}\n}","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here is an earlier preprint.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you use the partially observable functionality, we ask that you please cite the following:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@article{dowson_pomsp,\n\ttitle = {Partially observable multistage stochastic programming},\n\tdoi = {https://doi.org/10.1016/j.orl.2020.06.005},\n\tjournal = {Operations Research Letters},\n\tauthor = {Dowson, O., Morton, D.P., and Pagnoncelli, B.K.},\n\tvolume = {48},\n\tissue = {4},\n\tpages = {505-512},\n\tyear = {2020}\n}","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here is an earlier preprint.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you use the entropic risk measure, we ask that you please cite the following:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@article{dowson_entropic,\n\ttitle = {Multistage stochastic programs with the entropic risk measure},\n\tjournal = {Optimization Online},\n\tauthor = {Dowson, O., Morton, D.P., and Pagnoncelli, B.K.},\n\turl = {http://www.optimization-online.org/DB_HTML/2020/08/7984.html}\n\tyear = {2020}\n}","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here is a preprint.","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"EditURL = \"https://github.com/odow/SDDP.jl/blob/master/docs/src/examples/the_farmers_problem.jl\"","category":"page"},{"location":"examples/the_farmers_problem/#The-farmer's-problem","page":"The farmer's problem","title":"The farmer's problem","text":"","category":"section"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"This problem is taken from Section 1.1 of the book Birge, J. R., & Louveaux, F. (2011). Introduction to Stochastic Programming. New York, NY: Springer New York. Paragraphs in quotes are taken verbatim.","category":"page"},{"location":"examples/the_farmers_problem/#Problem-description","page":"The farmer's problem","title":"Problem description","text":"","category":"section"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"Consider a European farmer who specializes in raising wheat, corn, and sugar beets on his 500 acres of land. During the winter, [they want] to decide how much land to devote to each crop.","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"The farmer knows that at least 200 tons (T) of wheat and 240 T of corn are needed for cattle feed. These amounts can be raised on the farm or bought from a wholesaler. Any production in excess of the feeding requirement would be sold.","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"Over the last decade, mean selling prices have been \\$170 and \\$150 per ton of wheat and corn, respectively. The purchase prices are 40% more than this due to the wholesaler’s margin and transportation costs.","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"Another profitable crop is sugar beet, which [they expect] to sell at \\$36/T; however, the European Commission imposes a quota on sugar beet production. Any amount in excess of the quota can be sold only at \\$10/T. The farmer’s quota for next year is 6000 T.\"","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"Based on past experience, the farmer knows that the mean yield on [their] land is roughly 2.5 T, 3 T, and 20 T per acre for wheat, corn, and sugar beets, respectively.","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"[To introduce uncertainty,] assume some correlation among the yields of the different crops. A very simplified representation of this would be to assume that years are good, fair, or bad for all crops, resulting in above average, average, or below average yields for all crops. To fix these ideas, above and below average indicate a yield 20% above or below the mean yield.","category":"page"},{"location":"examples/the_farmers_problem/#Problem-data","page":"The farmer's problem","title":"Problem data","text":"","category":"section"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"The area of the farm.","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"MAX_AREA = 500.0","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"There are three crops:","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"CROPS = [:wheat, :corn, :sugar_beet]","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"Each of the crops has a different planting cost (\\$/acre).","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"PLANTING_COST = Dict(\n    :wheat      => 150.0,\n    :corn       => 230.0,\n    :sugar_beet => 260.0\n)","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"The farmer requires a minimum quantity of wheat and corn, but not of sugar beet (tonnes).","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"MIN_QUANTITIES = Dict(\n    :wheat      => 200.0,\n    :corn       => 240.0,\n    :sugar_beet =>   0.0\n)","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"In Europe, there is a quota system for producing crops. The farmer owns the following quota for each crop (tonnes):","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"QUOTA_MAX = Dict(\n    :wheat      =>     Inf,\n    :corn       =>     Inf,\n    :sugar_beet => 6_000.0\n)","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"The farmer can sell crops produced under the quota for the following amounts (\\$/tonne):","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"SELL_IN_QUOTA = Dict(\n    :wheat      => 170.0,\n    :corn       => 150.0,\n    :sugar_beet =>  36.0\n)","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"If they sell more than their alloted quota, the farmer earns the following on each tonne of crop above the quota (\\$/tonne):","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"SELL_NO_QUOTA = Dict(\n    :wheat      =>  0.0,\n    :corn       =>  0.0,\n    :sugar_beet => 10.0\n)","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"The purchase prices for wheat and corn are 40% more than their sales price. However, the description does not address the purchase price of sugar beet. Therefore, we use a large value of \\$1,000/tonne.","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"BUY_PRICE = Dict(\n    :wheat      =>   238.0,\n    :corn       =>   210.0,\n    :sugar_beet => 1_000.0\n)","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"On average, each crop has the following yield in tonnes/acre:","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"MEAN_YIELD = Dict(\n    :wheat      =>  2.5,\n    :corn       =>  3.0,\n    :sugar_beet => 20.0\n)","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"However, the yield is random. In good years, the yield is +20% above average, and in bad years, the yield is -20% below average.","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"YIELD_MULTIPLIER = Dict(\n    :good => 1.2,\n    :fair => 1.0,\n    :bad  => 0.8\n)","category":"page"},{"location":"examples/the_farmers_problem/#Mathematical-formulation","page":"The farmer's problem","title":"Mathematical formulation","text":"","category":"section"},{"location":"examples/the_farmers_problem/#SDDP.jl-code","page":"The farmer's problem","title":"SDDP.jl code","text":"","category":"section"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"note: Note\nIn what follows, we make heavy use of the fact that you can look up variables by their symbol name in a JuMP model as follows:@variable(model, x)\nmodel[:x]Read the JuMP documentation if this isn't familiar to you.","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"First up, load SDDP.jl and a solver. For this example, we use GLPK.jl.","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"using SDDP, GLPK","category":"page"},{"location":"examples/the_farmers_problem/#State-variables","page":"The farmer's problem","title":"State variables","text":"","category":"section"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"State variables are the information that flows between stages. In our example, the state variables are the areas of land devoted to growing each crop.","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"function add_state_variables(subproblem)\n    @variable(subproblem, area[c = CROPS] >= 0, SDDP.State, initial_value=0)\nend","category":"page"},{"location":"examples/the_farmers_problem/#First-stage-problem","page":"The farmer's problem","title":"First stage problem","text":"","category":"section"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"We can only plant a maximum of 500 acres, and we want to minimize the planting cost","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"function create_first_stage_problem(subproblem)\n    @constraint(subproblem,\n        sum(subproblem[:area][c].out for c in CROPS) <= MAX_AREA)\n    @stageobjective(subproblem,\n        -sum(PLANTING_COST[c] * subproblem[:area][c].out for c in CROPS))\nend","category":"page"},{"location":"examples/the_farmers_problem/#Second-stage-problem","page":"The farmer's problem","title":"Second stage problem","text":"","category":"section"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"Now let's consider the second stage problem. This is more complicated than the first stage, so we've broken it down into four sections:","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"control variables\nconstraints\nthe objective\nthe uncertainty","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"First, let's add the second stage control variables.","category":"page"},{"location":"examples/the_farmers_problem/#Variables","page":"The farmer's problem","title":"Variables","text":"","category":"section"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"We add four types of control variables. Technically, the yield isn't a control variable. However, we add it as a dummy \"helper\" variable because it will be used when we add uncertainty.","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"function second_stage_variables(subproblem)\n    @variables(subproblem, begin\n        0 <= yield[c=CROPS]                          # tonnes/acre\n        0 <= buy[c=CROPS]                            # tonnes\n        0 <= sell_in_quota[c=CROPS] <= QUOTA_MAX[c]  # tonnes\n        0 <= sell_no_quota[c=CROPS]                  # tonnes\n    end)\nend","category":"page"},{"location":"examples/the_farmers_problem/#Constraints","page":"The farmer's problem","title":"Constraints","text":"","category":"section"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"We need to define is the minimum quantity constraint. This ensures that MIN_QUANTITIES[c] of each crop is produced.","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"function second_stage_constraint_min_quantity(subproblem)\n    @constraint(subproblem, [c=CROPS],\n        subproblem[:yield][c] + subproblem[:buy][c] -\n        subproblem[:sell_in_quota][c] - subproblem[:sell_no_quota][c] >=\n        MIN_QUANTITIES[c])\nend","category":"page"},{"location":"examples/the_farmers_problem/#Objective","page":"The farmer's problem","title":"Objective","text":"","category":"section"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"The objective of the second stage is to maximise revenue from selling crops, less the cost of buying corn and wheat if necessary to meet the minimum quantity constraint.","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"function second_stage_objective(subproblem)\n    @stageobjective(subproblem,\n        sum(\n            SELL_IN_QUOTA[c] * subproblem[:sell_in_quota][c] +\n            SELL_NO_QUOTA[c] * subproblem[:sell_no_quota][c] -\n            BUY_PRICE[c] * subproblem[:buy][c]\n        for c in CROPS)\n    )\nend","category":"page"},{"location":"examples/the_farmers_problem/#Random-variables","page":"The farmer's problem","title":"Random variables","text":"","category":"section"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"Then, in the SDDP.parameterize function, we set the coefficient using JuMP.set_normalized_coefficient.","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"function second_stage_uncertainty(subproblem)\n    @constraint(subproblem, uncertainty[c=CROPS],\n        1.0 * subproblem[:area][c].in == subproblem[:yield][c])\n    SDDP.parameterize(subproblem, [:good, :fair, :bad]) do ω\n        for c in CROPS\n            JuMP.set_normalized_coefficient(\n                uncertainty[c],\n                subproblem[:area][c].in,\n                MEAN_YIELD[c] * YIELD_MULTIPLIER[ω]\n            )\n        end\n    end\nend","category":"page"},{"location":"examples/the_farmers_problem/#Putting-it-all-together","page":"The farmer's problem","title":"Putting it all together","text":"","category":"section"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"Now we're ready to build the multistage stochastic programming model. In addition to the things already discussed, we need a few extra pieces of information.","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"First, we are maximizing, so we set sense = :Max. Second, we need to provide a valid upper bound. (See Choosing an initial bound for more on this.) We know from Birge and Louveaux that the optimal solution is \\$108,390.  So, let's choose \\$500,000 just to be safe.","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"Here is the full model.","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"model = SDDP.LinearPolicyGraph(\n            stages = 2,\n            sense = :Max,\n            upper_bound = 500_000.0,\n            optimizer = GLPK.Optimizer,\n            direct_mode = false\n        ) do subproblem, stage\n    add_state_variables(subproblem)\n    if stage == 1\n        create_first_stage_problem(subproblem)\n    else\n        second_stage_variables(subproblem)\n        second_stage_constraint_min_quantity(subproblem)\n        second_stage_uncertainty(subproblem)\n        second_stage_objective(subproblem)\n    end\nend","category":"page"},{"location":"examples/the_farmers_problem/#Training-a-policy","page":"The farmer's problem","title":"Training a policy","text":"","category":"section"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"Now that we've built a model, we need to train it using SDDP.train. The keyword iteration_limit stops the training after 20 iterations. See Choose a stopping rule for other ways to stop the training.","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"SDDP.train(model; iteration_limit = 20)","category":"page"},{"location":"examples/the_farmers_problem/#Checking-the-policy","page":"The farmer's problem","title":"Checking the policy","text":"","category":"section"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"Birge and Louveaux report that the optimal objective value is \\$108,390. Check that we got the correct solution using SDDP.calculate_bound:","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"@assert SDDP.calculate_bound(model) == 108_390.0","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"","category":"page"},{"location":"examples/the_farmers_problem/","page":"The farmer's problem","title":"The farmer's problem","text":"This page was generated using Literate.jl.","category":"page"}]
}
