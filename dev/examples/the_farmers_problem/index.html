<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>The farmer&#39;s problem · SDDP.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../index.html"><img class="logo" src="../../assets/logo.png" alt="SDDP.jl logo"/></a><h1>SDDP.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><a class="toctext" href="../../upgrading_guide/">Upgrading guide</a></li><li><span class="toctext">Tutorials</span><ul><li><span class="toctext">Basic</span><ul><li><a class="toctext" href="../../tutorial/01_first_steps/">Basic I: first steps</a></li><li><a class="toctext" href="../../tutorial/02_adding_uncertainty/">Basic II: adding uncertainty</a></li><li><a class="toctext" href="../../tutorial/03_objective_uncertainty/">Basic III: objective uncertainty</a></li><li><a class="toctext" href="../../tutorial/04_markov_uncertainty/">Basic IV: Markov uncertainty</a></li><li><a class="toctext" href="../../tutorial/05_plotting/">Basic V: plotting</a></li><li><a class="toctext" href="../../tutorial/06_warnings/">Basic VI: words of warning</a></li><li><a class="toctext" href="../../tutorial/07_advanced_modelling/">Basic VII: modelling tips</a></li><li><a class="toctext" href="../../tutorial/08_debugging/">Basic VIII: debugging</a></li></ul></li><li><span class="toctext">Intermediate</span><ul><li><a class="toctext" href="../../tutorial/11_risk/">Intermediate I: risk</a></li><li><a class="toctext" href="../../tutorial/12_stopping_rules/">Intermediate II: stopping rules</a></li><li><a class="toctext" href="../../tutorial/13_generic_graphs/">Intermediate III: policy graphs</a></li><li><a class="toctext" href="../../tutorial/14_objective_states/">Intermediate IV: objective states</a></li><li><a class="toctext" href="../../tutorial/15_belief_states/">Intermediate V: belief states</a></li><li><a class="toctext" href="../../tutorial/16_performance/">Intermediate VI: performance</a></li></ul></li></ul></li><li><span class="toctext">Examples</span><ul><li class="current"><a class="toctext" href>The farmer&#39;s problem</a><ul class="internal"><li><a class="toctext" href="#Problem-description-1">Problem description</a></li><li><a class="toctext" href="#Problem-data-1">Problem data</a></li><li><a class="toctext" href="#Mathematical-formulation-1">Mathematical formulation</a></li><li><a class="toctext" href="#SDDP.jl-code-1">SDDP.jl code</a></li><li><a class="toctext" href="#Training-a-policy-1">Training a policy</a></li><li><a class="toctext" href="#Checking-the-policy-1">Checking the policy</a></li></ul></li></ul></li><li><a class="toctext" href="../../apireference/">Reference</a></li></ul></nav><article id="docs"><header><nav><ul><li>Examples</li><li><a href>The farmer&#39;s problem</a></li></ul><a class="edit-page" href="https://github.com/odow/SDDP.jl/blob/master/../../../../build/odow/SDDP.jl/docs/src/examples/the_farmers_problem.jl"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>The farmer&#39;s problem</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="The-farmer&#39;s-problem-1" href="#The-farmer&#39;s-problem-1">The farmer&#39;s problem</a></h1><p><em>This problem is taken from Section 1.1 of the book Birge, J. R., &amp; Louveaux, F. (2011). Introduction to Stochastic Programming. New York, NY: Springer New York. Paragraphs in quotes are taken verbatim.</em></p><h2><a class="nav-anchor" id="Problem-description-1" href="#Problem-description-1">Problem description</a></h2><blockquote><p>Consider a European farmer who specializes in raising wheat, corn, and sugar beets on his 500 acres of land. During the winter, [they want] to decide how much land to devote to each crop.</p></blockquote><blockquote><p>The farmer knows that at least 200 tons (T) of wheat and 240 T of corn are needed for cattle feed. These amounts can be raised on the farm or bought from a wholesaler. Any production in excess of the feeding requirement would be sold.</p></blockquote><blockquote><p>Over the last decade, mean selling prices have been \$170 and \$150 per ton of wheat and corn, respectively. The purchase prices are 40% more than this due to the wholesaler’s margin and transportation costs.</p></blockquote><blockquote><p>Another profitable crop is sugar beet, which [they expect] to sell at \$36/T; however, the European Commission imposes a quota on sugar beet production. Any amount in excess of the quota can be sold only at \$10/T. The farmer’s quota for next year is 6000 T.&quot;</p></blockquote><blockquote><p>Based on past experience, the farmer knows that the mean yield on [their] land is roughly 2.5 T, 3 T, and 20 T per acre for wheat, corn, and sugar beets, respectively.</p></blockquote><blockquote><p>[To introduce uncertainty,] assume some correlation among the yields of the different crops. A very simplified representation of this would be to assume that years are good, fair, or bad for all crops, resulting in above average, average, or below average yields for all crops. To fix these ideas, <em>above</em> and <em>below</em> average indicate a yield 20% above or below the mean yield.</p></blockquote><h2><a class="nav-anchor" id="Problem-data-1" href="#Problem-data-1">Problem data</a></h2><p>The area of the farm.</p><pre><code class="language-julia">MAX_AREA = 500.0</code></pre><pre><code class="language-none">500.0</code></pre><p>There are three crops:</p><pre><code class="language-julia">CROPS = [:wheat, :corn, :sugar_beet]</code></pre><pre><code class="language-none">3-element Array{Symbol,1}:
 :wheat     
 :corn      
 :sugar_beet</code></pre><p>Each of the crops has a different planting cost (\$/acre).</p><pre><code class="language-julia">PLANTING_COST = Dict(
    :wheat      =&gt; 150.0,
    :corn       =&gt; 230.0,
    :sugar_beet =&gt; 260.0
)</code></pre><pre><code class="language-none">Dict{Symbol,Float64} with 3 entries:
  :wheat      =&gt; 150.0
  :sugar_beet =&gt; 260.0
  :corn       =&gt; 230.0</code></pre><p>The farmer requires a minimum quantity of wheat and corn, but not of sugar beet (tonnes).</p><pre><code class="language-julia">MIN_QUANTITIES = Dict(
    :wheat      =&gt; 200.0,
    :corn       =&gt; 240.0,
    :sugar_beet =&gt;   0.0
)</code></pre><pre><code class="language-none">Dict{Symbol,Float64} with 3 entries:
  :wheat      =&gt; 200.0
  :sugar_beet =&gt; 0.0
  :corn       =&gt; 240.0</code></pre><p>In Europe, there is a quota system for producing crops. The farmer owns the following quota for each crop (tonnes):</p><pre><code class="language-julia">QUOTA_MAX = Dict(
    :wheat      =&gt;     Inf,
    :corn       =&gt;     Inf,
    :sugar_beet =&gt; 6_000.0
)</code></pre><pre><code class="language-none">Dict{Symbol,Float64} with 3 entries:
  :wheat      =&gt; Inf
  :sugar_beet =&gt; 6000.0
  :corn       =&gt; Inf</code></pre><p>The farmer can sell crops produced under the quota for the following amounts (\$/tonne):</p><pre><code class="language-julia">SELL_IN_QUOTA = Dict(
    :wheat      =&gt; 170.0,
    :corn       =&gt; 150.0,
    :sugar_beet =&gt;  36.0
)</code></pre><pre><code class="language-none">Dict{Symbol,Float64} with 3 entries:
  :wheat      =&gt; 170.0
  :sugar_beet =&gt; 36.0
  :corn       =&gt; 150.0</code></pre><p>If they sell more than their alloted quota, the farmer earns the following on each tonne of crop above the quota (\$/tonne):</p><pre><code class="language-julia">SELL_NO_QUOTA = Dict(
    :wheat      =&gt;  0.0,
    :corn       =&gt;  0.0,
    :sugar_beet =&gt; 10.0
)</code></pre><pre><code class="language-none">Dict{Symbol,Float64} with 3 entries:
  :wheat      =&gt; 0.0
  :sugar_beet =&gt; 10.0
  :corn       =&gt; 0.0</code></pre><p>The purchase prices for wheat and corn are 40% more than their sales price. However, the description does not address the purchase price of sugar beet. Therefore, we use a large value of \$1,000/tonne.</p><pre><code class="language-julia">BUY_PRICE = Dict(
    :wheat      =&gt;   238.0,
    :corn       =&gt;   210.0,
    :sugar_beet =&gt; 1_000.0
)</code></pre><pre><code class="language-none">Dict{Symbol,Float64} with 3 entries:
  :wheat      =&gt; 238.0
  :sugar_beet =&gt; 1000.0
  :corn       =&gt; 210.0</code></pre><p>On average, each crop has the following yield in tonnes/acre:</p><pre><code class="language-julia">MEAN_YIELD = Dict(
    :wheat      =&gt;  2.5,
    :corn       =&gt;  3.0,
    :sugar_beet =&gt; 20.0
)</code></pre><pre><code class="language-none">Dict{Symbol,Float64} with 3 entries:
  :wheat      =&gt; 2.5
  :sugar_beet =&gt; 20.0
  :corn       =&gt; 3.0</code></pre><p>However, the yield is random. In good years, the yield is +20% above average, and in bad years, the yield is -20% below average.</p><pre><code class="language-julia">YIELD_MULTIPLIER = Dict(
    :good =&gt; 1.2,
    :fair =&gt; 1.0,
    :bad  =&gt; 0.8
)</code></pre><pre><code class="language-none">Dict{Symbol,Float64} with 3 entries:
  :bad  =&gt; 0.8
  :good =&gt; 1.2
  :fair =&gt; 1.0</code></pre><h2><a class="nav-anchor" id="Mathematical-formulation-1" href="#Mathematical-formulation-1">Mathematical formulation</a></h2><h2><a class="nav-anchor" id="SDDP.jl-code-1" href="#SDDP.jl-code-1">SDDP.jl code</a></h2><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>In what follows, we make heavy use of the fact that you can look up variables by their symbol name in a JuMP model as follows:</p><pre><code class="language-julia">@variable(model, x)
model[:x]</code></pre><p>Read the <a href="http://www.juliaopt.org/JuMP.jl/v0.19/variables/">JuMP documentation</a> if this isn&#39;t familiar to you.</p></div></div><p>First up, load <code>SDDP.jl</code> and a solver. For this example, we use <a href="https://github.com/JuliaOpt/GLPK.jl"><code>GLPK.jl</code></a>.</p><pre><code class="language-julia">using SDDP, GLPK</code></pre><h3><a class="nav-anchor" id="State-variables-1" href="#State-variables-1">State variables</a></h3><p>State variables are the information that flows between stages. In our example, the state variables are the areas of land devoted to growing each crop.</p><pre><code class="language-julia">function add_state_variables(subproblem)
    @variable(subproblem, area[c = CROPS] &gt;= 0, SDDP.State, initial_value=0)
end</code></pre><pre><code class="language-none">add_state_variables (generic function with 1 method)</code></pre><h3><a class="nav-anchor" id="First-stage-problem-1" href="#First-stage-problem-1">First stage problem</a></h3><pre><code class="language-julia">function create_first_stage_problem(subproblem)</code></pre><p>We can only plant a maximum of 500 acres.</p><pre><code class="language-julia">    @constraint(subproblem,
        sum(subproblem[:area][c].out for c in CROPS) &lt;= MAX_AREA)</code></pre><p>Minimize the planting cost</p><pre><code class="language-julia">    @stageobjective(subproblem,
        -sum(PLANTING_COST[c] * subproblem[:area][c].out for c in CROPS))
end</code></pre><pre><code class="language-none">create_first_stage_problem (generic function with 1 method)</code></pre><h3><a class="nav-anchor" id="Second-stage-problem-1" href="#Second-stage-problem-1">Second stage problem</a></h3><p>Now let&#39;s consider the second stage problem. This is more complicated than the first stage, so we&#39;ve broken it down into four sections:</p><ol><li>control variables</li><li>constraints</li><li>the objective</li><li>the uncertainty</li></ol><p>First, let&#39;s add the second stage control variables.</p><h4><a class="nav-anchor" id="Variables-1" href="#Variables-1">Variables</a></h4><p>We add four types of control variables. Technically, the <code>yield</code> isn&#39;t a control variable. However, we add it as a dummy &quot;helper&quot; variable because it will be used when we add uncertainty.</p><pre><code class="language-julia">function second_stage_variables(subproblem)
    @variables(subproblem, begin
        0 &lt;= yield[c=CROPS]                          # tonnes/acre
        0 &lt;= buy[c=CROPS]                            # tonnes
        0 &lt;= sell_in_quota[c=CROPS] &lt;= QUOTA_MAX[c]  # tonnes
        0 &lt;= sell_no_quota[c=CROPS]                  # tonnes
    end)
end</code></pre><pre><code class="language-none">second_stage_variables (generic function with 1 method)</code></pre><h4><a class="nav-anchor" id="Constraints-1" href="#Constraints-1">Constraints</a></h4><p>We need to define is the minimum quantity constraint. This ensures that <code>MIN_QUANTITIES[c]</code> of each crop is produced.</p><pre><code class="language-julia">function second_stage_constraint_min_quantity(subproblem)
    @constraint(subproblem, [c=CROPS],
        subproblem[:yield][c] + subproblem[:buy][c] -
        subproblem[:sell_in_quota][c] - subproblem[:sell_no_quota][c] &gt;=
        MIN_QUANTITIES[c])
end</code></pre><pre><code class="language-none">second_stage_constraint_min_quantity (generic function with 1 method)</code></pre><h4><a class="nav-anchor" id="Objective-1" href="#Objective-1">Objective</a></h4><p>The objective of the second stage is to maximise revenue from selling crops, less the cost of buying corn and wheat if necessary to meet the minimum quantity constraint.</p><pre><code class="language-julia">function second_stage_objective(subproblem)
    @stageobjective(subproblem,
        sum(
            SELL_IN_QUOTA[c] * subproblem[:sell_in_quota][c] +
            SELL_NO_QUOTA[c] * subproblem[:sell_no_quota][c] -
            BUY_PRICE[c] * subproblem[:buy][c]
        for c in CROPS)
    )
end</code></pre><pre><code class="language-none">second_stage_objective (generic function with 1 method)</code></pre><h4><a class="nav-anchor" id="Random-variables-1" href="#Random-variables-1">Random variables</a></h4><p>Then, in the <a href="../../apireference/#SDDP.parameterize"><code>SDDP.parameterize</code></a> function, we set the coefficient using <code>JuMO.set_coefficient</code>.</p><pre><code class="language-julia">function second_stage_uncertainty(subproblem)
    @constraint(subproblem, uncertainty[c=CROPS],
        1.0 * subproblem[:area][c].in == subproblem[:yield][c])
    SDDP.parameterize(subproblem, [:good, :fair, :bad]) do ω
        for c in CROPS
            JuMP.set_coefficient(
                uncertainty[c],
                subproblem[:area][c].in,
                MEAN_YIELD[c] * YIELD_MULTIPLIER[ω]
            )
        end
    end
end</code></pre><pre><code class="language-none">second_stage_uncertainty (generic function with 1 method)</code></pre><h3><a class="nav-anchor" id="Putting-it-all-together-1" href="#Putting-it-all-together-1">Putting it all together</a></h3><p>Now we&#39;re ready to build the multistage stochastic programming model. In addition to the things already discussed, we need a few extra pieces of information.</p><p>First, we maximizing, so we set <code>sense = :Max</code>. Second, we need to provide a valid upper bound. (See <a href="../../tutorial/06_warnings/#Choosing-an-initial-bound-1">Choosing an initial bound</a> for more on this.) We know from Birge and Louveaux that the optimal solution is \$108,390. So, let&#39;s choose \$500,000 just to be safe.</p><p>Here is the full model.</p><pre><code class="language-julia">model = SDDP.LinearPolicyGraph(
            stages = 2,
            sense = :Max,
            upper_bound = 500_000.0,
            optimizer = with_optimizer(GLPK.Optimizer),
            direct_mode = false
        ) do subproblem, stage
    add_state_variables(subproblem)
    if stage == 1
        create_first_stage_problem(subproblem)
    else
        second_stage_variables(subproblem)
        second_stage_constraint_min_quantity(subproblem)
        second_stage_uncertainty(subproblem)
        second_stage_objective(subproblem)
    end
end</code></pre><pre><code class="language-none">A policy graph with 2 nodes.
 Node indices: 1, 2
</code></pre><h2><a class="nav-anchor" id="Training-a-policy-1" href="#Training-a-policy-1">Training a policy</a></h2><p>Now that we&#39;ve built a model, we need to train it using <a href="../../apireference/#SDDP.train"><code>SDDP.train</code></a>. The keyword <code>iteration_limit</code> stops the training after 20 iterations. See <a href="../../tutorial/12_stopping_rules/#Intermediate-II:-stopping-rules-1">Intermediate II: stopping rules</a> for other ways to stop the training.</p><pre><code class="language-julia">SDDP.train(model; iteration_limit = 20)</code></pre><pre><code class="language-none">-------------------------------------------------------
         SDDP.jl (c) Oscar Dowson, 2017-19

Numerical stability report
  Non-zero Matrix range     [1e+00, 2e+01]
  Non-zero Objective range  [1e+00, 1e+03]
  Non-zero Bounds range     [6e+03, Inf]
  Non-zero RHS range        [2e+02, 5e+02]
WARNING: numerical stability issues detected
  - Bounds range contains large coefficients
Very large or small absolute values of coefficients
can cause numerical stability issues. Consider
reformulating the model.

 Iteration    Simulation       Bound         Time (s)
        1   -9.800000e+04   1.320000e+05   1.111984e-03
        2    8.000000e+03   1.290000e+05   1.479149e-03
        3    4.840000e+04   1.268139e+05   1.836061e-03
        4    3.003659e+04   1.219636e+05   2.178192e-03
        5    1.550000e+05   1.121210e+05   2.519131e-03
        6    1.121210e+05   1.104195e+05   2.876997e-03
        7    4.784940e+04   1.095042e+05   3.194094e-03
        8    1.095042e+05   1.088611e+05   3.516197e-03
        9    4.956667e+04   1.088021e+05   3.856182e-03
       10    1.655812e+05   1.084962e+05   4.269123e-03
       11    1.084962e+05   1.083900e+05   4.599094e-03
       12    1.093500e+05   1.083900e+05   4.935026e-03
       13    1.670000e+05   1.083900e+05   5.351067e-03
       14    1.093500e+05   1.083900e+05   5.683184e-03
       15    4.882000e+04   1.083900e+05   6.000996e-03
       16    4.882000e+04   1.083900e+05   6.335974e-03
       17    4.882000e+04   1.083900e+05   6.658077e-03
       18    1.670000e+05   1.083900e+05   6.973028e-03
       19    1.670000e+05   1.083900e+05   7.280111e-03
       20    4.882000e+04   1.083900e+05   7.583141e-03

Terminating training with status: iteration_limit
-------------------------------------------------------</code></pre><h2><a class="nav-anchor" id="Checking-the-policy-1" href="#Checking-the-policy-1">Checking the policy</a></h2><p>Birge and Louveaux report that the optimal objective value is \$108,390. Check that we got the correct solution using <a href="../../apireference/#SDDP.calculate_bound"><code>SDDP.calculate_bound</code></a>:</p><pre><code class="language-julia">@assert SDDP.calculate_bound(model) == 108_390.0</code></pre><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p><footer><hr/><a class="previous" href="../../tutorial/16_performance/"><span class="direction">Previous</span><span class="title">Intermediate VI: performance</span></a><a class="next" href="../../apireference/"><span class="direction">Next</span><span class="title">Reference</span></a></footer></article></body></html>
