<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · SDDP.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>SDDP.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../upgrading_guide/">Upgrading guide</a></li><li><span class="toctext">Tutorials</span><ul><li><span class="toctext">Basic</span><ul><li><a class="toctext" href="../tutorial/01_first_steps/">Basic I: first steps</a></li><li><a class="toctext" href="../tutorial/02_adding_uncertainty/">Basic II: adding uncertainty</a></li><li><a class="toctext" href="../tutorial/03_objective_uncertainty/">Basic III: objective uncertainty</a></li><li><a class="toctext" href="../tutorial/04_markov_uncertainty/">Basic IV: Markov uncertainty</a></li><li><a class="toctext" href="../tutorial/05_plotting/">Basic V: plotting</a></li><li><a class="toctext" href="../tutorial/06_warnings/">Basic VI: words of warning</a></li><li><a class="toctext" href="../tutorial/07_advanced_modelling/">Basic VII: modelling tips</a></li><li><a class="toctext" href="../tutorial/08_debugging/">Basic VIII: debugging</a></li></ul></li><li><span class="toctext">Intermediate</span><ul><li><a class="toctext" href="../tutorial/11_risk/">Intermediate I: risk</a></li><li><a class="toctext" href="../tutorial/12_stopping_rules/">Intermediate II: stopping rules</a></li><li><a class="toctext" href="../tutorial/13_generic_graphs/">Intermediate III: policy graphs</a></li><li><a class="toctext" href="../tutorial/14_objective_states/">Intermediate IV: objective states</a></li><li><a class="toctext" href="../tutorial/15_belief_states/">Intermediate V: belief states</a></li><li><a class="toctext" href="../tutorial/16_performance/">Intermediate VI: performance</a></li></ul></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../examples/the_farmers_problem/">The farmer&#39;s problem</a></li></ul></li><li class="current"><a class="toctext" href>Reference</a><ul class="internal"><li><a class="toctext" href="#Policy-graphs-1">Policy graphs</a></li><li><a class="toctext" href="#Subproblem-definition-1">Subproblem definition</a></li><li><a class="toctext" href="#Training-the-policy-1">Training the policy</a></li><li><a class="toctext" href="#Simulating-the-policy-1">Simulating the policy</a></li><li><a class="toctext" href="#Visualizing-the-policy-1">Visualizing the policy</a></li><li><a class="toctext" href="#Debugging-the-model-1">Debugging the model</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Reference</a></li></ul><a class="edit-page" href="https://github.com/odow/SDDP.jl/blob/master/docs/src/apireference.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Reference</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="API-Reference-1" href="#API-Reference-1">API Reference</a></h1><h2><a class="nav-anchor" id="Policy-graphs-1" href="#Policy-graphs-1">Policy graphs</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SDDP.Graph" href="#SDDP.Graph"><code>SDDP.Graph</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Graph(root_node::T) where T</code></pre><p>Create an empty graph struture with the root node <code>root_node</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SDDP.add_node" href="#SDDP.add_node"><code>SDDP.add_node</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">add_node(graph::Graph{T}, node::T) where T</code></pre><p>Add a node to the graph <code>graph</code>.</p><p><strong>Examples</strong></p><pre><code class="language-none">add_node(graph, :A)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SDDP.add_edge" href="#SDDP.add_edge"><code>SDDP.add_edge</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">add_edge(graph::Graph{T}, edge::Pair{T, T}, probability::Float64) where T</code></pre><p>Add an edge to the graph <code>graph</code>.</p><p><strong>Examples</strong></p><pre><code class="language-none">add_edge(graph, 1 =&gt; 2, 0.9)
add_edge(graph, :root =&gt; :A, 1.0)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SDDP.add_ambiguity_set" href="#SDDP.add_ambiguity_set"><code>SDDP.add_ambiguity_set</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">add_ambiguity_set(graph::Graph{T}, set::Vector{T})</code></pre><p>Add <code>set</code> to the belief partition of <code>graph</code>.</p><p><strong>Examples</strong></p><pre><code class="language-none">graph = LinearGraph(3)
add_ambiguity_set(graph, [1, 2])
add_ambiguity_set(graph, [3])</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SDDP.LinearGraph" href="#SDDP.LinearGraph"><code>SDDP.LinearGraph</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">LinearGraph(stages::Int)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SDDP.MarkovianGraph" href="#SDDP.MarkovianGraph"><code>SDDP.MarkovianGraph</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">MarkovianGraph(transition_matrices::Vector{Matrix{Float64}})</code></pre></div></div><div><div><pre><code class="language-none">MarkovianGraph(; stages::Int,
               transition_matrix::Matrix{Float64},
               root_node_transition::Vector{Float64})</code></pre><p>Construct a Markovian graph object.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SDDP.LinearPolicyGraph" href="#SDDP.LinearPolicyGraph"><code>SDDP.LinearPolicyGraph</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">LinearPolicyGraph(builder::Function; stages::Int, kwargs...)</code></pre><p>Create a linear policy graph with <code>stages</code> number of stages.</p><p>See <a href="#SDDP.PolicyGraph"><code>SDDP.PolicyGraph</code></a> for the other keyword arguments.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SDDP.MarkovianPolicyGraph" href="#SDDP.MarkovianPolicyGraph"><code>SDDP.MarkovianPolicyGraph</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">MarkovianPolicyGraph(builder::Function;
    transition_matrices::Vector{Array{Float64, 2}}, kwargs...)</code></pre><p>Create a Markovian policy graph based on the transition matrices given in <code>transition_matrices</code>.</p><p>See <a href="#SDDP.PolicyGraph"><code>SDDP.PolicyGraph</code></a> for the other keyword arguments.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SDDP.PolicyGraph" href="#SDDP.PolicyGraph"><code>SDDP.PolicyGraph</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">PolicyGraph(builder::Function, graph::Graph{T};
    sense = :Min,
    bellman_function = nothing,
    lower_bound = -Inf,
    upper_bound = Inf,
    optimizer = nothing,
    direct_mode = true,
    lipschitz_belief = Dict{T, Float64}()) where {T}</code></pre><p>Construct a policy graph based on the graph structure of <code>graph</code>. (See <a href="#SDDP.Graph"><code>SDDP.Graph</code></a> for details.)</p><p><strong>Example</strong></p><pre><code class="language-none">function builder(subproblem::JuMP.Model, index)
    # ... subproblem definition ...
end

model = PolicyGraph(builder, graph;
                    lower_bound = 0.0,
                    optimizer = with_optimizer(GLPK.Optimizer),
                    direct_mode = false)</code></pre><p>Or, using the Julia <code>do ... end</code> syntax:</p><pre><code class="language-none">model = PolicyGraph(graph;
                    lower_bound = 0.0,
                    optimizer = with_optimizer(GLPK.Optimizer),
                    direct_mode = true) do subproblem, index
    # ... subproblem definitions ...
end</code></pre></div></div></section><h2><a class="nav-anchor" id="Subproblem-definition-1" href="#Subproblem-definition-1">Subproblem definition</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SDDP.@stageobjective" href="#SDDP.@stageobjective"><code>SDDP.@stageobjective</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">@stageobjective(subproblem, expr)</code></pre><p>Set the stage-objective of <code>subproblem</code> to <code>expr</code>.</p><p><strong>Example</strong></p><pre><code class="language-none">@stageobjective(subproblem, 2x + y)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SDDP.parameterize" href="#SDDP.parameterize"><code>SDDP.parameterize</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">parameterize(modify::Function,
             subproblem::JuMP.Model,
             realizations::Vector{T},
             probability::Vector{Float64} = fill(1.0 / length(realizations))
                 ) where T</code></pre><p>Add a parameterization function <code>modify</code> to <code>subproblem</code>. The <code>modify</code> function takes one argument and modifies <code>subproblem</code> based on the realization of the noise sampled from <code>realizations</code> with corresponding probabilities <code>probability</code>.</p><p>In order to conduct an out-of-sample simulation, <code>modify</code> should accept arguments that are not in realizations (but still of type T).</p><p><strong>Example</strong></p><pre><code class="language-none">SDDP.parameterize(subproblem, [1, 2, 3], [0.4, 0.3, 0.3]) do ω
    JuMP.set_upper_bound(x, ω)
end</code></pre></div></div><div><div><pre><code class="language-none">parameterize(node::Node, noise)</code></pre><p>Parameterize node <code>node</code> with the noise <code>noise</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SDDP.add_objective_state" href="#SDDP.add_objective_state"><code>SDDP.add_objective_state</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">add_objective_state(update::Function, subproblem::JuMP.Model; kwargs...)</code></pre><p>Add an objective state variable to <code>subproblem</code>.</p><p>Required <code>kwargs</code> are:</p><ul><li><code>initial_value</code>: The initial value of the objective state variable at the  root node.</li><li><code>lipschitz</code>: The lipschitz constant of the objective state variable.</li></ul><p>Setting a tight value for the lipschitz constant can significantly improve the speed of convergence.</p><p>Optional <code>kwargs</code> are:</p><ul><li><code>lower_bound</code>: A valid lower bound for the objective state variable. Can be  <code>-Inf</code>.</li><li><code>upper_bound</code>: A valid upper bound for the objective state variable. Can be  <code>+Inf</code>.</li></ul><p>Setting tight values for these optional variables can significantly improve the speed of convergence.</p><p>If the objective state is <code>N</code>-dimensional, each keyword argument must be an <code>NTuple{N, Float64}</code>. For example, <code>initial_value = (0.0, 1.0)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SDDP.objective_state" href="#SDDP.objective_state"><code>SDDP.objective_state</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">objective_state(subproblem::JuMP.Model)</code></pre><p>Return the current objective state of the problem.</p><p>Can only be called from <a href="#SDDP.parameterize"><code>SDDP.parameterize</code></a>.</p></div></div></section><h2><a class="nav-anchor" id="Training-the-policy-1" href="#Training-the-policy-1">Training the policy</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SDDP.numerical_stability_report" href="#SDDP.numerical_stability_report"><code>SDDP.numerical_stability_report</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">numerical_stability_report([io::IO=stdout,] model::PolicyGraph,
                           by_node::Bool=false, print=true, warn::Bool=true)</code></pre><p>Print a report identifying possible numeric stability issues.</p><ul><li>If <code>by_node</code>, print a report for each node in the graph.</li><li>If <code>print</code>, print to <code>io</code>.</li><li>If <code>warn</code>, warn if the coefficients may cause numerical issues.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SDDP.train" href="#SDDP.train"><code>SDDP.train</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">SDDP.train(model::PolicyGraph; kwargs...)</code></pre><p>Train the policy for <code>model</code>. Keyword arguments:</p><ul><li><p><code>iteration_limit::Int</code>: number of iterations to conduct before termination</p></li><li><p><code>time_limit::Float64</code>: number of seconds to train before termination</p></li><li><p><code>stoping_rules</code>: a vector of <a href="#SDDP.AbstractStoppingRule"><code>SDDP.AbstractStoppingRule</code></a></p></li><li><p><code>print_level</code>: control the level of printing to the screen</p></li><li><p><code>log_file</code>: filepath at which to write a log of the training progress</p></li><li><p>run<em>numerical</em>stability_report: generate a numerical stability report prior to solve</p></li><li><p><code>refine_at_similar_nodes::Bool</code>: if SDDP can detect that two nodes have the  same children, it can cheaply add a cut discovered at one to the other. In  almost all cases this should be set to <code>true</code>.</p></li><li><p><code>cut_deletion_minimum::Int</code>: the minimum number of cuts to cache before  deleting  cuts from the subproblem. This is solver specific; however,  smaller values  result in smaller subproblems, at the expense of more time  spent performing cut selection.</p></li><li><p><code>risk_measure</code>: the risk measure to use at each node.</p></li><li><p><code>sampling_scheme</code>: a sampling scheme to use on the forward pass of the algorithm. Defaults to InSampleMonteCarlo().</p></li></ul><p>There is also a special option for infinite horizon problems</p><ul><li>cycle<em>discretization</em>delta: the maximum distance between states allowed on the forward pass. This is for advanced users only and needs to be used in conjunction with a different <code>sampling_scheme</code>.</li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SDDP.termination_status" href="#SDDP.termination_status"><code>SDDP.termination_status</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">termination_status(model::PolicyGraph)</code></pre><p>Query the reason why the training stopped.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SDDP.write_cuts_to_file" href="#SDDP.write_cuts_to_file"><code>SDDP.write_cuts_to_file</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">write_cuts_to_file(model::PolicyGraph{T}, filename::String) where {T}</code></pre><p>Write the cuts that form the policy in <code>model</code> to <code>filename</code> in JSON format.</p><p>See also <a href="#SDDP.read_cuts_from_file"><code>SDDP.read_cuts_from_file</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SDDP.read_cuts_from_file" href="#SDDP.read_cuts_from_file"><code>SDDP.read_cuts_from_file</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">read_cuts_from_file(
    model::PolicyGraph{T}, filename::String;
    node_name_parser::Function = _node_name_parser) where {T}</code></pre><p>Read cuts (saved using <a href="#SDDP.write_cuts_to_file"><code>SDDP.write_cuts_to_file</code></a>) from <code>filename</code> into <code>model</code>.</p><p>Since <code>T</code> can be an arbitrary Julia type, the conversion to JSON is lossy. When reading, <code>read_cuts_from_file</code> only supports <code>T=Int</code>, <code>T=NTuple{N, Int}</code>, and <code>T=Symbol</code>. If you have manually created a policy graph with a different node type <code>T</code>, provide a function <code>node_name_parser</code> with the signature <code>node_name_parser(T, name::String)::T where {T}</code> that returns the name of each node given the string name <code>name</code>.</p><p>See also <a href="#SDDP.write_cuts_to_file"><code>SDDP.write_cuts_to_file</code></a>.</p></div></div></section><h3><a class="nav-anchor" id="Stopping-rules-1" href="#Stopping-rules-1">Stopping rules</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SDDP.AbstractStoppingRule" href="#SDDP.AbstractStoppingRule"><code>SDDP.AbstractStoppingRule</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractStoppingRule</code></pre><p>The abstract type for the stopping-rule interface.</p><p>You need to define the following methods:</p><ul><li><a href="#SDDP.stopping_rule_status"><code>SDDP.stopping_rule_status</code></a></li><li><a href="#SDDP.convergence_test"><code>SDDP.convergence_test</code></a></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SDDP.stopping_rule_status" href="#SDDP.stopping_rule_status"><code>SDDP.stopping_rule_status</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">stopping_rule_status(::AbstractStoppingRule)::Symbol</code></pre><p>Return a symbol describing the stopping rule.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SDDP.convergence_test" href="#SDDP.convergence_test"><code>SDDP.convergence_test</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">convergence_test(model::PolicyGraph, log::Vector{Log}, ::AbstractStoppingRule)::Bool</code></pre><p>Return a <code>Bool</code> indicating if the algorithm should terminate the training.</p></div></div></section><h3><a class="nav-anchor" id="Sampling-schemes-1" href="#Sampling-schemes-1">Sampling schemes</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SDDP.AbstractSamplingScheme" href="#SDDP.AbstractSamplingScheme"><code>SDDP.AbstractSamplingScheme</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractSamplingScheme</code></pre><p>The abstract type for the sampling-scheme interface.</p><p>You need to define the following methods:</p><ul><li><a href="#SDDP.sample_scenario"><code>SDDP.sample_scenario</code></a></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SDDP.sample_scenario" href="#SDDP.sample_scenario"><code>SDDP.sample_scenario</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">sample_scenario(graph::PolicyGraph{T}, ::AbstractSamplingScheme) where T</code></pre><p>Sample a scenario from the policy graph <code>graph</code> based on the sampling scheme.</p><p>Returns <code>::Tuple{Vector{Tuple{T, &lt;:Any}}, Bool}</code>, where the first element is the scenario, and the second element is a Boolean flag indicating if the scenario was terminated due to the detection of a cycle.</p><p>The scenario is a list of tuples (type <code>Vector{Tuple{T, &lt;:Any}}</code>) where the first component of each tuple is the index of the node, and the second component is the stagewise-independent noise term observed in that node.</p></div></div></section><h3><a class="nav-anchor" id="Sampling-schemes-2" href="#Sampling-schemes-2">Sampling schemes</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SDDP.AbstractRiskMeasure" href="#SDDP.AbstractRiskMeasure"><code>SDDP.AbstractRiskMeasure</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractRiskMeasure</code></pre><p>The abstract type for the risk measure interface.</p><p>You need to define the following methods:</p><ul><li><a href="#SDDP.adjust_probability"><code>SDDP.adjust_probability</code></a></li></ul></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SDDP.adjust_probability" href="#SDDP.adjust_probability"><code>SDDP.adjust_probability</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">adjust_probability(measure::Expectation
                   risk_adjusted_probability::Vector{Float64},
                   original_probability::Vector{Float64},
                   noise_support::Vector{Noise{T}},
                   objective_realizations::Vector{Float64},
                   is_minimization::Bool) where T</code></pre></div></div></section><h2><a class="nav-anchor" id="Simulating-the-policy-1" href="#Simulating-the-policy-1">Simulating the policy</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SDDP.simulate" href="#SDDP.simulate"><code>SDDP.simulate</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">simulate(model::PolicyGraph,
         number_replications::Int = 1,
         variables::Vector{Symbol} = Symbol[];
         sampling_scheme::AbstractSamplingScheme =
             InSampleMonteCarlo(),
         custom_recorders = Dict{Symbol, Function}()
 )::Vector{Vector{Dict{Symbol, Any}}}</code></pre><p>Perform a simulation of the policy model with <code>number_replications</code> replications using the sampling scheme <code>sampling_scheme</code>.</p><p>Returns a vector with one element for each replication. Each element is a vector with one-element for each node in the scenario that was sampled. Each element in that vector is a dictionary containing information about the subproblem that was solved.</p><p>In that dictionary there are four special keys:</p><ul><li>:node_index, which records the index of the sampled node in the policy model</li><li>:noise_term, which records the noise observed at the node</li><li>:stage_objective, which records the stage-objective of the subproblem</li><li>:bellman_term, which records the cost/value-to-go of the node.</li></ul><p>The sum of :stage<em>objective + :bellman</em>term will equal the objective value of the solved subproblem.</p><p>In addition to the special keys, the dictionary will contain the result of <code>JuMP.value(subproblem[key])</code> for each <code>key</code> in <code>variables</code>. This is useful to obtain the primal value of the state and control variables.</p><p>For more complicated data, the <code>custom_recorders</code> keyword arguement can be used.</p><pre><code class="language-none">data = Dict{Symbol, Any}()
for (key, recorder) in custom_recorders
    data[key] = foo(subproblem)
end</code></pre><p>For example, to record the dual of a constraint named <code>my_constraint</code>, pass the following:</p><pre><code class="language-none">simulation_results = simulate(model, number_replications=2;
    custom_recorders = Dict(
        :constraint_dual = (sp) -&gt; JuMP.dual(sp[:my_constraint])
    )
)</code></pre><p>The value of the dual in the first stage of the second replication can be accessed as:</p><pre><code class="language-none">simulation_results[2][1][:constraint_dual]</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SDDP.calculate_bound" href="#SDDP.calculate_bound"><code>SDDP.calculate_bound</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">SDDP.calculate_bound(model::PolicyGraph, state::Dict{Symbol, Float64},
                       risk_measure=Expectation())</code></pre><p>Calculate the lower bound (if minimizing, otherwise upper bound) of the problem model at the point state, assuming the risk measure at the root node is risk_measure.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SDDP.Historical" href="#SDDP.Historical"><code>SDDP.Historical</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Historical(scenarios::Vector{Vector{Tuple{T, S}}},
           probability::Vector{Float64})</code></pre><p>A sampling scheme that samples a scenario from the vector of scenarios <code>scenarios</code> according to <code>probability</code>. If probability omitted, defaults to uniform probability.</p><p><strong>Example</strong></p><pre><code class="language-none">Historical(
    [
        [(1, 0.5), (2, 1.0), (3, 0.5)],
        [(1, 0.5), (2, 0.0), (3, 1.0)],
        [(1, 1.0), (2, 0.0), (3, 0.0)]
    ],
    [0.2, 0.5, 0.3]
)</code></pre></div></div><div><div><pre><code class="language-none">Historical(scenario::Vector{Tuple{T, S}})</code></pre><p>A deterministic sampling scheme that always samples <code>scenario</code> with probability <code>1</code>.</p><p><strong>Example</strong></p><pre><code class="language-none">Historical([(1, 0.5), (2, 1.5), (3, 0.75)])</code></pre></div></div></section><h2><a class="nav-anchor" id="Visualizing-the-policy-1" href="#Visualizing-the-policy-1">Visualizing the policy</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SDDP.SpaghettiPlot" href="#SDDP.SpaghettiPlot"><code>SDDP.SpaghettiPlot</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">SDDP.SpaghettiPlot(; stages, scenarios)</code></pre><p>Initialize a new <code>SpaghettiPlot</code> with <code>stages</code> stages and <code>scenarios</code> number of replications.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SDDP.add_spaghetti" href="#SDDP.add_spaghetti"><code>SDDP.add_spaghetti</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">SDDP.add_spaghetti(data_function::Function, plt::SpaghettiPlot; kwargs...)</code></pre><p><strong>Description</strong></p><p>Add a new figure to the SpaghettiPlot <code>plt</code>, where the y-value of the <code>scenario</code>th line when x = <code>stage</code> is given by <code>data_function(plt.simulations[scenario][stage])</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>xlabel</code>: set the xaxis label</li><li><code>ylabel</code>: set the yaxis label</li><li><code>title</code>: set the title of the plot</li><li><code>ymin</code>: set the minimum y value</li><li><code>ymax</code>: set the maximum y value</li><li><code>cumulative</code>: plot the additive accumulation of the value across the stages</li><li><code>interpolate</code>: interpolation method for lines between stages.</li></ul><p>Defaults to <code>&quot;linear&quot;</code> see <a href="https://github.com/d3/d3-3.x-api-reference/blob/master/SVG-Shapes.md#line_interpolate">the d3 docs</a> 	for all options.</p><p><strong>Examples</strong></p><pre><code class="language-none">simulations = simulate(model, 10)
plt = SDDP.spaghetti_plot(simulations)
SDDP.add_spaghetti(plt; title = &quot;Stage objective&quot;) do data
	return data[:stage_objective]
end</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SDDP.publication_plot" href="#SDDP.publication_plot"><code>SDDP.publication_plot</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">SDDP.publication_plot(
    data_function, simulations;
    quantile = [0.0, 0.1, 0.25, 0.5, 0.75, 0.9, 1.0],
    kwargs...)</code></pre><p>Create a <code>Plots.jl</code> recipe plot of the simulations.</p><p>See <code>Plots.jl</code> for the list of keyword arguments.</p><p><strong>Example</strong></p><pre><code class="language-none">SDDP.publication_plot(simulations; title = &quot;My title&quot;) do data
    return data[:stage_objective]
end</code></pre></div></div></section><h2><a class="nav-anchor" id="Debugging-the-model-1" href="#Debugging-the-model-1">Debugging the model</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SDDP.write_subproblem_to_file" href="#SDDP.write_subproblem_to_file"><code>SDDP.write_subproblem_to_file</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">write_subproblem_to_file(node::Node, filename::String; format=:both)</code></pre><p>Write the subproblem contained in <code>node</code> to the file <code>filename</code>.</p><p><code>format</code> should be one of <code>:mps</code>, <code>:lp</code>, or <code>:both</code>.</p></div></div></section><footer><hr/><a class="previous" href="../examples/the_farmers_problem/"><span class="direction">Previous</span><span class="title">The farmer&#39;s problem</span></a></footer></article></body></html>
